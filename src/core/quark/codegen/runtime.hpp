// runtime.hpp - Quark Runtime Library (Auto-generated)
// DO NOT EDIT - Generated by build_runtime.ps1
// Regenerate with: cd runtime && pwsh build_runtime.ps1

#ifndef QUARK_RUNTIME_HPP
#define QUARK_RUNTIME_HPP

// Standard library includes
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cctype>
#include <cstdarg>
#include <algorithm>
#include <vector>
#include <unordered_map>
#include <string>

// ============================================================
// core/gc.hpp
// ============================================================

// quark/core/gc.hpp - Boehm GC integration wrapper
// Boehm GC configuration
// Define QUARK_USE_GC to enable garbage collection
// Otherwise falls back to manual memory management (leaking for now)

#ifdef QUARK_USE_GC
    #include <gc.h>

    // Initialize GC (call once at program start)
    inline void q_gc_init() {
        GC_INIT();
    }

    // GC allocation macros (expand to Boehm GC calls)
    #define q_malloc(n)         GC_MALLOC(n)
    #define q_malloc_atomic(n)  GC_MALLOC_ATOMIC(n)
    #define q_realloc(p, n)     GC_REALLOC(p, n)
    #define q_free(p)           /* GC handles it */
    #define q_strdup(s)         GC_STRDUP(s)

    // For future tensor/array data (no pointer scanning needed)
    #define q_malloc_tensor(n)  GC_MALLOC_ATOMIC(n)

#else
    // No GC - use standard malloc (will leak for now)
    #include <cstdlib>
    #include <cstring>

    inline void q_gc_init() {
        // No-op when GC disabled
    }

    #define q_malloc(n)         malloc(n)
    #define q_malloc_atomic(n)  malloc(n)
    #define q_realloc(p, n)     realloc(p, n)
    #define q_free(p)           free(p)

    inline char* q_strdup(const char* s) {
        return strdup(s);
    }

    #define q_malloc_tensor(n)  malloc(n)
#endif

// ============================================================
// core/value.hpp
// ============================================================

// quark/core/value.hpp - QValue tagged union type
#include <cstdlib>
#include <vector>

// Forward declarations
struct QValue;
struct QResult;
struct QDict;
struct QClosure;
struct QVector;

// Type alias for list storage
using QList = std::vector<QValue>;

// QValue: Tagged union for all Quark runtime values
struct QValue {
        enum ValueType {
        VAL_INT,
        VAL_FLOAT,
        VAL_STRING,
        VAL_BOOL,
        VAL_NULL,
        VAL_LIST,
        VAL_VECTOR,
        VAL_DICT,
        VAL_FUNC,
        VAL_RESULT
    } type;

    union {
        long long int_val;
        double float_val;
        char* string_val;
        bool bool_val;
        QList* list_val;    // std::vector<QValue>* - automatic memory management
        QVector* vector_val; // typed column vector (f64/i64/bool/str/cat)
        QDict* dict_val;    // std::unordered_map<std::string, QValue>*
        void* func_val;
        QResult* result_val;
    } data;
};

// Function pointer types: all take QClosure* as hidden first parameter
using QClFunc0 = QValue (*)(QClosure*);
using QClFunc1 = QValue (*)(QClosure*, QValue);
using QClFunc2 = QValue (*)(QClosure*, QValue, QValue);
using QClFunc3 = QValue (*)(QClosure*, QValue, QValue, QValue);
using QClFunc4 = QValue (*)(QClosure*, QValue, QValue, QValue, QValue);

struct QResult {
    bool is_ok;
    QValue payload;
};

// ============================================================
// core/constructors.hpp
// ============================================================

// quark/core/constructors.hpp - QValue constructors
#include <cstring>
#include <cstdarg>

// Integer value constructor
inline QValue qv_int(long long v) {
    QValue q;
    q.type = QValue::VAL_INT;
    q.data.int_val = v;
    return q;
}

// Float value constructor
inline QValue qv_float(double v) {
    QValue q;
    q.type = QValue::VAL_FLOAT;
    q.data.float_val = v;
    return q;
}

// String value constructor (makes a copy using GC)
inline QValue qv_string(const char* v) {
    QValue q;
    if (!v) {
        q.type = QValue::VAL_NULL;
        return q;
    }
    q.type = QValue::VAL_STRING;
    q.data.string_val = q_strdup(v);
    return q;
}

// Boolean value constructor
inline QValue qv_bool(bool v) {
    QValue q;
    q.type = QValue::VAL_BOOL;
    q.data.bool_val = v;
    return q;
}

// Null value constructor
inline QValue qv_null() {
    QValue q;
    q.type = QValue::VAL_NULL;
    return q;
}

// Function value constructor - wraps raw pointer in a QClosure with 0 captures
inline QValue qv_func(void* f) {
    QClosure* cl = q_alloc_closure(f, 0);
    QValue q;
    q.type = QValue::VAL_FUNC;
    q.data.func_val = cl;
    return q;
}

inline QValue qv_ok(QValue v) {
    QValue q;
    QResult* result = static_cast<QResult*>(q_malloc(sizeof(QResult)));
    if (!result) { q.type = QValue::VAL_NULL; return q; }
    q.type = QValue::VAL_RESULT;
    result->is_ok = true;
    result->payload = v;
    q.data.result_val = result;
    return q;
}

inline QValue qv_err(QValue v) {
    QValue q;
    QResult* result = static_cast<QResult*>(q_malloc(sizeof(QResult)));
    if (!result) { q.type = QValue::VAL_NULL; return q; }
    q.type = QValue::VAL_RESULT;
    result->is_ok = false;
    result->payload = v;
    q.data.result_val = result;
    return q;
}

inline bool q_is_ok(const QValue& v) {
    return v.type == QValue::VAL_RESULT && v.data.result_val && v.data.result_val->is_ok;
}

inline QValue q_result_value(const QValue& v) {
    if (v.type == QValue::VAL_RESULT && v.data.result_val && v.data.result_val->is_ok) {
        return v.data.result_val->payload;
    }
    return qv_null();
}

inline QValue q_result_error(const QValue& v) {
    if (v.type == QValue::VAL_RESULT && v.data.result_val && !v.data.result_val->is_ok) {
        return v.data.result_val->payload;
    }
    return qv_null();
}

// List value constructor with optional initial capacity
// Note: std::vector internally uses new/delete, which Boehm GC intercepts
inline QValue qv_list(int initial_cap = 0) {
    QValue q;
    q.type = QValue::VAL_LIST;
    q.data.list_val = new QList();  // Boehm GC intercepts operator new
    if (initial_cap > 0) {
        q.data.list_val->reserve(initial_cap);
    }
    return q;
}

// List value constructor from variadic arguments
inline QValue qv_list_from(int count, ...) {
    QValue q;
    q.type = QValue::VAL_LIST;
    q.data.list_val = new QList();  // Boehm GC intercepts operator new
    q.data.list_val->reserve(count);
    va_list args;
    va_start(args, count);
    for (int i = 0; i < count; i++) {
        q.data.list_val->push_back(va_arg(args, QValue));
    }
    va_end(args);
    return q;
}

// List value constructor from initializer list (C++ style)
inline QValue qv_list_init(std::initializer_list<QValue> items) {
    QValue q;
    q.type = QValue::VAL_LIST;
    q.data.list_val = new QList(items);  // Boehm GC intercepts operator new
    return q;
}

// ============================================================
// types/dict.hpp
// ============================================================

// quark/types/dict.hpp - Dict operations using std::unordered_map
#include <unordered_map>
#include <string>
#include <cstdio>

struct QDict {
    std::unordered_map<std::string, QValue> entries;
};

inline QValue qv_dict() {
    QValue q;
    q.type = QValue::VAL_DICT;
    q.data.dict_val = new QDict();
    return q;
}

inline bool q_require_dict(const QValue& v, const char* action) {
    if (v.type == QValue::VAL_DICT) {
        return true;
    }
    std::fprintf(stderr, "runtime error: %s expects dict\n", action);
    return false;
}

inline bool q_require_string_key(const QValue& key) {
    if (key.type == QValue::VAL_STRING) {
        return true;
    }
    std::fprintf(stderr, "runtime error: dict key must be string\n");
    return false;
}

inline QValue q_dict_get(QValue dict, QValue key) {
    if (!q_require_dict(dict, "dict get")) {
        return qv_null();
    }
    if (!q_require_string_key(key)) {
        return qv_null();
    }
    if (!dict.data.dict_val) {
        return qv_null();
    }
    auto it = dict.data.dict_val->entries.find(key.data.string_val ? key.data.string_val : "");
    if (it == dict.data.dict_val->entries.end()) {
        return qv_null();
    }
    return it->second;
}

inline QValue q_dict_set(QValue dict, QValue key, QValue value) {
    if (!q_require_dict(dict, "dict set")) {
        return qv_null();
    }
    if (!q_require_string_key(key)) {
        return qv_null();
    }
    if (!dict.data.dict_val) {
        dict.data.dict_val = new QDict();
    }
    dict.data.dict_val->entries[std::string(key.data.string_val ? key.data.string_val : "")] = value;
    return dict;
}

inline QValue q_dict_has(QValue dict, QValue key) {
    if (!q_require_dict(dict, "dict has")) {
        return qv_bool(false);
    }
    if (!q_require_string_key(key)) {
        return qv_bool(false);
    }
    if (!dict.data.dict_val) {
        return qv_bool(false);
    }
    auto it = dict.data.dict_val->entries.find(key.data.string_val ? key.data.string_val : "");
    return qv_bool(it != dict.data.dict_val->entries.end());
}

inline int q_dict_size(QValue dict) {
    if (!q_require_dict(dict, "dict size")) {
        return 0;
    }
    if (!dict.data.dict_val) {
        return 0;
    }
    return static_cast<int>(dict.data.dict_val->entries.size());
}

// ============================================================
// types/string.hpp
// ============================================================

// quark/types/string.hpp - String operations
#include <cstring>
#include <cctype>
#include <cstdlib>

// Convert string to uppercase
inline QValue q_upper(QValue v) {
    // Type guard: only STRING is valid
    if (v.type != QValue::VAL_STRING || !v.data.string_val) return qv_null();
    char* result = q_strdup(v.data.string_val);
    for (int i = 0; result[i]; i++) {
        result[i] = static_cast<char>(toupper(static_cast<unsigned char>(result[i])));
    }
    QValue q = qv_string(result);
    // GC will handle cleanup - no explicit free needed
    return q;
}

// Convert string to lowercase
inline QValue q_lower(QValue v) {
    // Type guard: only STRING is valid
    if (v.type != QValue::VAL_STRING || !v.data.string_val) return qv_null();
    char* result = q_strdup(v.data.string_val);
    for (int i = 0; result[i]; i++) {
        result[i] = static_cast<char>(tolower(static_cast<unsigned char>(result[i])));
    }
    QValue q = qv_string(result);
    // GC will handle cleanup - no explicit free needed
    return q;
}

// Trim whitespace from both ends
inline QValue q_trim(QValue v) {
    // Type guard: only STRING is valid
    if (v.type != QValue::VAL_STRING || !v.data.string_val) return qv_null();
    const char* start = v.data.string_val;
    while (*start && isspace(static_cast<unsigned char>(*start))) start++;
    if (*start == '\0') return qv_string("");

    const char* end = v.data.string_val + strlen(v.data.string_val) - 1;
    while (end > start && isspace(static_cast<unsigned char>(*end))) end--;

    size_t len = static_cast<size_t>(end - start + 1);
    char* result = static_cast<char*>(q_malloc_atomic(len + 1));
    strncpy(result, start, len);
    result[len] = '\0';

    QValue q = qv_string(result);
    // GC will handle cleanup - no explicit free needed
    return q;
}

// Check if string contains substring
inline QValue q_contains(QValue str, QValue sub) {
    // Type guard: both must be STRING with non-null pointers
    if (str.type != QValue::VAL_STRING || sub.type != QValue::VAL_STRING ||
        !str.data.string_val || !sub.data.string_val) {
        return qv_null();
    }
    return qv_bool(strstr(str.data.string_val, sub.data.string_val) != nullptr);
}

// Check if string starts with prefix
inline QValue q_startswith(QValue str, QValue prefix) {
    // Type guard: both must be STRING with non-null pointers
    if (str.type != QValue::VAL_STRING || prefix.type != QValue::VAL_STRING ||
        !str.data.string_val || !prefix.data.string_val) {
        return qv_null();
    }
    size_t plen = strlen(prefix.data.string_val);
    return qv_bool(strncmp(str.data.string_val, prefix.data.string_val, plen) == 0);
}

// Check if string ends with suffix
inline QValue q_endswith(QValue str, QValue suffix) {
    // Type guard: both must be STRING with non-null pointers
    if (str.type != QValue::VAL_STRING || suffix.type != QValue::VAL_STRING ||
        !str.data.string_val || !suffix.data.string_val) {
        return qv_null();
    }
    size_t slen = strlen(str.data.string_val);
    size_t suflen = strlen(suffix.data.string_val);
    if (suflen > slen) return qv_bool(false);
    return qv_bool(strcmp(str.data.string_val + slen - suflen, suffix.data.string_val) == 0);
}

// Replace all occurrences of old_str with new_str
inline QValue q_replace(QValue str, QValue old_str, QValue new_str) {
    // Type guard: all must be STRING with non-null pointers
    if (str.type != QValue::VAL_STRING || old_str.type != QValue::VAL_STRING ||
        new_str.type != QValue::VAL_STRING ||
        !str.data.string_val || !old_str.data.string_val || !new_str.data.string_val) {
        return qv_null();
    }

    const char* s = str.data.string_val;
    const char* o = old_str.data.string_val;
    const char* n = new_str.data.string_val;
    size_t olen = strlen(o);
    size_t nlen = strlen(n);
    if (olen == 0) return str;

    // Count occurrences
    int count = 0;
    const char* tmp = s;
    while ((tmp = strstr(tmp, o)) != nullptr) {
        count++;
        tmp += olen;
    }

    // Allocate result (use atomic since it's just chars, no pointers)
    size_t slen = strlen(s);
    // Guard against size overflow when replacement is longer than original
    size_t rlen;
    if (nlen >= olen) {
        size_t extra = nlen - olen;
        if (extra > 0 && static_cast<size_t>(count) > (SIZE_MAX - slen) / extra) {
            return qv_null(); // overflow
        }
        rlen = slen + static_cast<size_t>(count) * extra;
    } else {
        rlen = slen - static_cast<size_t>(count) * (olen - nlen);
    }
    char* result = static_cast<char*>(q_malloc_atomic(rlen + 1));
    if (!result) return qv_null();
    char* dest = result;

    while (*s) {
        if (strncmp(s, o, olen) == 0) {
            memcpy(dest, n, nlen);
            dest += nlen;
            s += olen;
        } else {
            *dest++ = *s++;
        }
    }
    *dest = '\0';

    QValue q = qv_string(result);
    // GC will handle cleanup - no explicit free needed
    return q;
}

// Concatenate two strings
inline QValue q_str_concat(QValue a, QValue b) {
    if (a.type != QValue::VAL_STRING || b.type != QValue::VAL_STRING ||
        !a.data.string_val || !b.data.string_val) {
        return qv_null();
    }
    size_t alen = strlen(a.data.string_val);
    size_t blen = strlen(b.data.string_val);
    char* result = static_cast<char*>(q_malloc_atomic(alen + blen + 1));
    if (!result) return qv_null();
    memcpy(result, a.data.string_val, alen);
    memcpy(result + alen, b.data.string_val, blen);
    result[alen + blen] = '\0';
    return qv_string(result);
}

// Get character at index (supports negative indexing)
inline QValue q_str_get(QValue str, QValue index) {
    if (str.type != QValue::VAL_STRING || str.data.string_val == nullptr) {
        return qv_null();
    }
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }
    int len = static_cast<int>(strlen(str.data.string_val));
    int idx = static_cast<int>(index.data.int_val);
    if (idx < 0) idx = len + idx;
    if (idx < 0 || idx >= len) {
        return qv_null();
    }
    char buf[2];
    buf[0] = str.data.string_val[idx];
    buf[1] = '\0';
    return qv_string(buf);
}

// ============================================================
// types/vector.hpp
// ============================================================

// quark/types/vector.hpp - Typed 1D vector runtime kernels
#include <algorithm>
#include <cstdio>
#include <cstdint>
#include <cstring>
#include <unordered_map>
#include <string>
#include <variant>
#include <vector>

struct QStringStorage {
    std::vector<uint32_t> offsets;
    std::vector<char> bytes;
};

struct QNullMask {
    std::vector<uint8_t> is_null; // 0 = valid, 1 = null
};

struct QVector {
    enum class Type { F64, I64, BOOL, STR };

    Type type;
    size_t count;
    bool has_nulls;
    std::variant<
        std::vector<double>,
        std::vector<int64_t>,
        std::vector<uint8_t>,
        QStringStorage
    > storage;
    QNullMask nulls;

    QVector()
        : type(Type::F64),
          count(0),
          has_nulls(false),
          storage(std::vector<double>{}),
          nulls() {}
};

inline bool q_vec_has_valid_handle(QValue vec) {
    return vec.type == QValue::VAL_VECTOR && vec.data.vector_val;
}

inline bool q_vec_storage_matches_type(const QVector& vec) {
    switch (vec.type) {
        case QVector::Type::F64: return std::holds_alternative<std::vector<double>>(vec.storage);
        case QVector::Type::I64: return std::holds_alternative<std::vector<int64_t>>(vec.storage);
        case QVector::Type::BOOL: return std::holds_alternative<std::vector<uint8_t>>(vec.storage);
        case QVector::Type::STR: return std::holds_alternative<QStringStorage>(vec.storage);
        default: return false;
    }
}

inline bool q_vec_validate(const QVector& vec) {
    if (!q_vec_storage_matches_type(vec)) {
        return false;
    }

    switch (vec.type) {
        case QVector::Type::F64:
            if (std::get<std::vector<double>>(vec.storage).size() != vec.count) {
                return false;
            }
            break;
        case QVector::Type::I64:
            if (std::get<std::vector<int64_t>>(vec.storage).size() != vec.count) {
                return false;
            }
            break;
        case QVector::Type::BOOL:
            if (std::get<std::vector<uint8_t>>(vec.storage).size() != vec.count) {
                return false;
            }
            break;
        case QVector::Type::STR: {
            const QStringStorage& s = std::get<QStringStorage>(vec.storage);
            if (s.offsets.size() != vec.count + 1 || s.offsets.empty() || s.offsets.front() != 0) {
                return false;
            }
            if (static_cast<size_t>(s.offsets.back()) != s.bytes.size()) {
                return false;
            }
            for (size_t i = 1; i < s.offsets.size(); i++) {
                if (s.offsets[i] < s.offsets[i - 1]) {
                    return false;
                }
            }
            break;
        }
    }

    if (!vec.has_nulls) {
        return vec.nulls.is_null.empty();
    }

    return vec.nulls.is_null.size() == vec.count;
}

inline const char* q_vec_dtype_name(const QVector& vec) {
    switch (vec.type) {
        case QVector::Type::F64: return "f64";
        case QVector::Type::I64: return "i64";
        case QVector::Type::BOOL: return "bool";
        case QVector::Type::STR: return "str";
        default: return "unknown";
    }
}

inline bool q_vec_is_type(QValue vec, QVector::Type type) {
    return q_vec_has_valid_handle(vec) && vec.data.vector_val->type == type && q_vec_validate(*vec.data.vector_val);
}

inline std::vector<double>* q_vec_f64_mut(QValue vec) {
    if (!q_vec_is_type(vec, QVector::Type::F64)) {
        return nullptr;
    }
    return &std::get<std::vector<double>>(vec.data.vector_val->storage);
}

inline const std::vector<double>* q_vec_f64_const(QValue vec) {
    if (!q_vec_is_type(vec, QVector::Type::F64)) {
        return nullptr;
    }
    return &std::get<std::vector<double>>(vec.data.vector_val->storage);
}

inline std::vector<int64_t>* q_vec_i64_mut(QValue vec) {
    if (!q_vec_is_type(vec, QVector::Type::I64)) {
        return nullptr;
    }
    return &std::get<std::vector<int64_t>>(vec.data.vector_val->storage);
}

inline const std::vector<int64_t>* q_vec_i64_const(QValue vec) {
    if (!q_vec_is_type(vec, QVector::Type::I64)) {
        return nullptr;
    }
    return &std::get<std::vector<int64_t>>(vec.data.vector_val->storage);
}

inline std::vector<uint8_t>* q_vec_bool_mut(QValue vec) {
    if (!q_vec_is_type(vec, QVector::Type::BOOL)) {
        return nullptr;
    }
    return &std::get<std::vector<uint8_t>>(vec.data.vector_val->storage);
}

inline const std::vector<uint8_t>* q_vec_bool_const(QValue vec) {
    if (!q_vec_is_type(vec, QVector::Type::BOOL)) {
        return nullptr;
    }
    return &std::get<std::vector<uint8_t>>(vec.data.vector_val->storage);
}

inline void q_vec_ensure_null_mask(QVector& vec) {
    if (!vec.has_nulls) {
        vec.has_nulls = true;
        vec.nulls.is_null.assign(vec.count, static_cast<uint8_t>(0));
    }
}

inline bool q_vec_is_null_at(const QVector& vec, size_t index) {
    if (!vec.has_nulls || index >= vec.count) {
        return false;
    }
    return vec.nulls.is_null[index] != 0;
}

inline bool q_vec_set_null_at(QValue vec, size_t index, bool is_null) {
    if (!q_vec_has_valid_handle(vec) || index >= vec.data.vector_val->count) {
        return false;
    }
    QVector& qvec = *vec.data.vector_val;
    q_vec_ensure_null_mask(qvec);
    qvec.nulls.is_null[index] = static_cast<uint8_t>(is_null ? 1 : 0);
    return true;
}

inline bool q_is_numeric_scalar(QValue v) {
    return v.type == QValue::VAL_INT || v.type == QValue::VAL_FLOAT;
}

inline bool q_is_integral_scalar(QValue v) {
    return v.type == QValue::VAL_INT || v.type == QValue::VAL_BOOL;
}

inline bool q_is_boolish_scalar(QValue v) {
    return v.type == QValue::VAL_BOOL || v.type == QValue::VAL_INT;
}

inline double q_to_double_scalar(QValue v) {
    return v.type == QValue::VAL_FLOAT ? v.data.float_val : static_cast<double>(v.data.int_val);
}

inline int64_t q_to_i64_scalar(QValue v) {
    if (v.type == QValue::VAL_BOOL) {
        return v.data.bool_val ? 1 : 0;
    }
    if (v.type == QValue::VAL_FLOAT) {
        return static_cast<int64_t>(v.data.float_val);
    }
    return static_cast<int64_t>(v.data.int_val);
}

inline QValue qv_vector(int initial_cap = 0) {
    QValue q;
    q.type = QValue::VAL_VECTOR;
    q.data.vector_val = new QVector();
    if (initial_cap > 0) {
        std::get<std::vector<double>>(q.data.vector_val->storage).reserve(static_cast<size_t>(initial_cap));
    }
    return q;
}

inline QValue qv_vector_i64(int initial_cap = 0) {
    QValue q;
    q.type = QValue::VAL_VECTOR;
    q.data.vector_val = new QVector();
    q.data.vector_val->type = QVector::Type::I64;
    q.data.vector_val->storage = std::vector<int64_t>{};
    if (initial_cap > 0) {
        std::get<std::vector<int64_t>>(q.data.vector_val->storage).reserve(static_cast<size_t>(initial_cap));
    }
    return q;
}

inline QValue qv_vector_bool(int initial_cap = 0) {
    QValue q;
    q.type = QValue::VAL_VECTOR;
    q.data.vector_val = new QVector();
    q.data.vector_val->type = QVector::Type::BOOL;
    q.data.vector_val->storage = std::vector<uint8_t>{};
    if (initial_cap > 0) {
        std::get<std::vector<uint8_t>>(q.data.vector_val->storage).reserve(static_cast<size_t>(initial_cap));
    }
    return q;
}

inline QValue qv_vector_str(int initial_string_cap = 0, int initial_byte_cap = 0) {
    QValue q;
    q.type = QValue::VAL_VECTOR;
    q.data.vector_val = new QVector();
    q.data.vector_val->type = QVector::Type::STR;
    QStringStorage storage;
    storage.offsets.push_back(0);
    if (initial_string_cap > 0) {
        storage.offsets.reserve(static_cast<size_t>(initial_string_cap) + 1);
    }
    if (initial_byte_cap > 0) {
        storage.bytes.reserve(static_cast<size_t>(initial_byte_cap));
    }
    q.data.vector_val->storage = std::move(storage);
    return q;
}

inline QValue q_vec_push(QValue vec, QValue value) {
    if (!q_vec_has_valid_handle(vec)) {
        return qv_null();
    }
    if (vec.data.vector_val->type != QVector::Type::F64) {
        return qv_null();
    }
    if (!q_is_numeric_scalar(value)) {
        return qv_null();
    }
    std::vector<double>& values = std::get<std::vector<double>>(vec.data.vector_val->storage);
    values.push_back(q_to_double_scalar(value));
    vec.data.vector_val->count = values.size();
    if (vec.data.vector_val->has_nulls) {
        vec.data.vector_val->nulls.is_null.push_back(0);
    }
    return vec;
}

inline QValue q_vec_push_i64(QValue vec, QValue value) {
    if (!q_vec_has_valid_handle(vec) || vec.data.vector_val->type != QVector::Type::I64) {
        return qv_null();
    }
    if (!(value.type == QValue::VAL_INT || value.type == QValue::VAL_FLOAT || value.type == QValue::VAL_BOOL)) {
        return qv_null();
    }
    std::vector<int64_t>& values = std::get<std::vector<int64_t>>(vec.data.vector_val->storage);
    values.push_back(q_to_i64_scalar(value));
    vec.data.vector_val->count = values.size();
    if (vec.data.vector_val->has_nulls) {
        vec.data.vector_val->nulls.is_null.push_back(0);
    }
    return vec;
}

inline QValue q_vec_push_bool(QValue vec, QValue value) {
    if (!q_vec_has_valid_handle(vec) || vec.data.vector_val->type != QVector::Type::BOOL) {
        return qv_null();
    }
    if (!q_is_boolish_scalar(value)) {
        return qv_null();
    }
    std::vector<uint8_t>& values = std::get<std::vector<uint8_t>>(vec.data.vector_val->storage);
    const bool b = (value.type == QValue::VAL_BOOL) ? value.data.bool_val : (value.data.int_val != 0);
    values.push_back(static_cast<uint8_t>(b ? 1 : 0));
    vec.data.vector_val->count = values.size();
    if (vec.data.vector_val->has_nulls) {
        vec.data.vector_val->nulls.is_null.push_back(0);
    }
    return vec;
}

inline QStringStorage q_vec_encode_strings(const std::vector<std::string>& values) {
    QStringStorage out;
    out.offsets.reserve(values.size() + 1);
    out.offsets.push_back(0);
    size_t total = 0;
    for (const auto& s : values) {
        total += s.size();
        out.bytes.insert(out.bytes.end(), s.begin(), s.end());
        out.offsets.push_back(static_cast<uint32_t>(total));
    }
    return out;
}

inline std::vector<std::string> q_vec_decode_strings(const QStringStorage& storage, size_t count) {
    std::vector<std::string> values;
    values.reserve(count);
    for (size_t i = 0; i < count; i++) {
        uint32_t start = storage.offsets[i];
        uint32_t end = storage.offsets[i + 1];
        values.emplace_back(storage.bytes.data() + start, storage.bytes.data() + end);
    }
    return values;
}

inline QValue q_vec_clone(QValue vec) {
    if (!q_vec_has_valid_handle(vec) || !q_vec_validate(*vec.data.vector_val)) {
        return qv_null();
    }
    QValue out;
    out.type = QValue::VAL_VECTOR;
    out.data.vector_val = new QVector(*vec.data.vector_val);
    return out;
}

inline int q_vec_size(QValue vec) {
    if (!q_vec_has_valid_handle(vec) || !q_vec_validate(*vec.data.vector_val)) {
        return 0;
    }
    return static_cast<int>(vec.data.vector_val->count);
}

inline QValue q_vec_dtype(QValue vec) {
    if (!q_vec_has_valid_handle(vec) || !q_vec_validate(*vec.data.vector_val)) {
        return qv_null();
    }
    return qv_string(q_vec_dtype_name(*vec.data.vector_val));
}

template <typename BinaryOp>
inline QValue q_vec_binary_impl(QValue a, QValue b, BinaryOp op) {
    const bool aVec = q_vec_has_valid_handle(a);
    const bool bVec = q_vec_has_valid_handle(b);

    if (!aVec && !bVec) {
        return qv_null();
    }

    if (aVec && bVec) {
        const std::vector<double>* avp = q_vec_f64_const(a);
        const std::vector<double>* bvp = q_vec_f64_const(b);
        if (!avp || !bvp) {
            return qv_null();
        }
        const std::vector<double>& av = *avp;
        const std::vector<double>& bv = *bvp;
        if (av.size() != bv.size()) {
            return qv_null();
        }
        QValue out = qv_vector(static_cast<int>(av.size()));
        std::vector<double>& outv = std::get<std::vector<double>>(out.data.vector_val->storage);
        outv.resize(av.size());
        out.data.vector_val->count = av.size();

        for (size_t i = 0; i < av.size(); i++) {
            outv[i] = op(av[i], bv[i]);
        }
        return out;
    }

    if (aVec && q_is_numeric_scalar(b)) {
        const std::vector<double>* avp = q_vec_f64_const(a);
        if (!avp) {
            return qv_null();
        }
        const std::vector<double>& av = *avp;
        double bs = q_to_double_scalar(b);
        QValue out = qv_vector(static_cast<int>(av.size()));
        std::vector<double>& outv = std::get<std::vector<double>>(out.data.vector_val->storage);
        outv.resize(av.size());
        out.data.vector_val->count = av.size();
        for (size_t i = 0; i < av.size(); i++) {
            outv[i] = op(av[i], bs);
        }
        return out;
    }

    if (bVec && q_is_numeric_scalar(a)) {
        const std::vector<double>* bvp = q_vec_f64_const(b);
        if (!bvp) {
            return qv_null();
        }
        const std::vector<double>& bv = *bvp;
        double as = q_to_double_scalar(a);
        QValue out = qv_vector(static_cast<int>(bv.size()));
        std::vector<double>& outv = std::get<std::vector<double>>(out.data.vector_val->storage);
        outv.resize(bv.size());
        out.data.vector_val->count = bv.size();
        for (size_t i = 0; i < bv.size(); i++) {
            outv[i] = op(as, bv[i]);
        }
        return out;
    }

    return qv_null();
}

template <typename BinaryOp>
inline QValue q_vec_binary_i64_impl(QValue a, QValue b, BinaryOp op) {
    const bool aVec = q_vec_has_valid_handle(a);
    const bool bVec = q_vec_has_valid_handle(b);

    if (aVec && bVec) {
        const std::vector<int64_t>* avp = q_vec_i64_const(a);
        const std::vector<int64_t>* bvp = q_vec_i64_const(b);
        if (!avp || !bvp || avp->size() != bvp->size()) {
            return qv_null();
        }
        QValue out = qv_vector_i64(static_cast<int>(avp->size()));
        std::vector<int64_t>& outv = std::get<std::vector<int64_t>>(out.data.vector_val->storage);
        outv.resize(avp->size());
        out.data.vector_val->count = avp->size();
        for (size_t i = 0; i < avp->size(); i++) {
            outv[i] = op((*avp)[i], (*bvp)[i]);
        }
        return out;
    }

    if (aVec && q_is_integral_scalar(b)) {
        const std::vector<int64_t>* avp = q_vec_i64_const(a);
        if (!avp) {
            return qv_null();
        }
        const int64_t bs = q_to_i64_scalar(b);
        QValue out = qv_vector_i64(static_cast<int>(avp->size()));
        std::vector<int64_t>& outv = std::get<std::vector<int64_t>>(out.data.vector_val->storage);
        outv.resize(avp->size());
        out.data.vector_val->count = avp->size();
        for (size_t i = 0; i < avp->size(); i++) {
            outv[i] = op((*avp)[i], bs);
        }
        return out;
    }

    if (bVec && q_is_integral_scalar(a)) {
        const std::vector<int64_t>* bvp = q_vec_i64_const(b);
        if (!bvp) {
            return qv_null();
        }
        const int64_t as = q_to_i64_scalar(a);
        QValue out = qv_vector_i64(static_cast<int>(bvp->size()));
        std::vector<int64_t>& outv = std::get<std::vector<int64_t>>(out.data.vector_val->storage);
        outv.resize(bvp->size());
        out.data.vector_val->count = bvp->size();
        for (size_t i = 0; i < bvp->size(); i++) {
            outv[i] = op(as, (*bvp)[i]);
        }
        return out;
    }

    return qv_null();
}

inline QValue q_vec_div_i64(QValue a, QValue b) {
    const bool aVec = q_vec_has_valid_handle(a);
    const bool bVec = q_vec_has_valid_handle(b);

    if (aVec && bVec) {
        const std::vector<int64_t>* avp = q_vec_i64_const(a);
        const std::vector<int64_t>* bvp = q_vec_i64_const(b);
        if (!avp || !bvp || avp->size() != bvp->size()) {
            return qv_null();
        }
        QValue out = qv_vector(static_cast<int>(avp->size()));
        std::vector<double>& outv = std::get<std::vector<double>>(out.data.vector_val->storage);
        outv.resize(avp->size());
        out.data.vector_val->count = avp->size();
        for (size_t i = 0; i < avp->size(); i++) {
            outv[i] = static_cast<double>((*avp)[i]) / static_cast<double>((*bvp)[i]);
        }
        return out;
    }

    if (aVec && q_is_integral_scalar(b)) {
        const std::vector<int64_t>* avp = q_vec_i64_const(a);
        if (!avp) {
            return qv_null();
        }
        const double bs = static_cast<double>(q_to_i64_scalar(b));
        QValue out = qv_vector(static_cast<int>(avp->size()));
        std::vector<double>& outv = std::get<std::vector<double>>(out.data.vector_val->storage);
        outv.resize(avp->size());
        out.data.vector_val->count = avp->size();
        for (size_t i = 0; i < avp->size(); i++) {
            outv[i] = static_cast<double>((*avp)[i]) / bs;
        }
        return out;
    }

    if (bVec && q_is_integral_scalar(a)) {
        const std::vector<int64_t>* bvp = q_vec_i64_const(b);
        if (!bvp) {
            return qv_null();
        }
        const double as = static_cast<double>(q_to_i64_scalar(a));
        QValue out = qv_vector(static_cast<int>(bvp->size()));
        std::vector<double>& outv = std::get<std::vector<double>>(out.data.vector_val->storage);
        outv.resize(bvp->size());
        out.data.vector_val->count = bvp->size();
        for (size_t i = 0; i < bvp->size(); i++) {
            outv[i] = as / static_cast<double>((*bvp)[i]);
        }
        return out;
    }

    return qv_null();
}

inline QValue q_vec_add(QValue a, QValue b) {
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_binary_i64_impl(a, b, [](int64_t x, int64_t y) { return x + y; });
        if (out.type != QValue::VAL_NULL) {
            return out;
        }
    }
    return q_vec_binary_impl(a, b, [](double x, double y) { return x + y; });
}

inline QValue q_vec_sub(QValue a, QValue b) {
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_binary_i64_impl(a, b, [](int64_t x, int64_t y) { return x - y; });
        if (out.type != QValue::VAL_NULL) {
            return out;
        }
    }
    return q_vec_binary_impl(a, b, [](double x, double y) { return x - y; });
}

inline QValue q_vec_mul(QValue a, QValue b) {
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_binary_i64_impl(a, b, [](int64_t x, int64_t y) { return x * y; });
        if (out.type != QValue::VAL_NULL) {
            return out;
        }
    }
    return q_vec_binary_impl(a, b, [](double x, double y) { return x * y; });
}

inline QValue q_vec_div(QValue a, QValue b) {
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_div_i64(a, b);
        if (out.type != QValue::VAL_NULL) {
            return out;
        }
    }
    return q_vec_binary_impl(a, b, [](double x, double y) { return x / y; });
}

inline QValue q_vec_sum(QValue vec) {
    const std::vector<int64_t>* vi = q_vec_i64_const(vec);
    if (vi) {
        double acc = 0.0;
        for (size_t i = 0; i < vi->size(); i++) {
            acc += static_cast<double>((*vi)[i]);
        }
        return qv_float(acc);
    }

    const std::vector<uint8_t>* vb = q_vec_bool_const(vec);
    if (vb) {
        double acc = 0.0;
        for (size_t i = 0; i < vb->size(); i++) {
            acc += ((*vb)[i] != 0) ? 1.0 : 0.0;
        }
        return qv_float(acc);
    }

    const std::vector<double>* vp = q_vec_f64_const(vec);
    if (!vp) {
        return qv_null();
    }
    const std::vector<double>& v = *vp;
    double acc = 0.0;
    for (size_t i = 0; i < v.size(); i++) {
        acc += v[i];
    }
    return qv_float(acc);
}

inline QValue q_vec_min(QValue vec) {
    const std::vector<int64_t>* vi = q_vec_i64_const(vec);
    if (vi && !vi->empty()) {
        int64_t cur = (*vi)[0];
        for (size_t i = 1; i < vi->size(); i++) {
            cur = std::min(cur, (*vi)[i]);
        }
        return qv_float(static_cast<double>(cur));
    }

    const std::vector<double>* vp = q_vec_f64_const(vec);
    if (!vp || vp->empty()) {
        return qv_null();
    }
    const std::vector<double>& v = *vp;
    double cur = v[0];
    for (size_t i = 1; i < v.size(); i++) {
        cur = std::min(cur, v[i]);
    }
    return qv_float(cur);
}

inline QValue q_vec_max(QValue vec) {
    const std::vector<int64_t>* vi = q_vec_i64_const(vec);
    if (vi && !vi->empty()) {
        int64_t cur = (*vi)[0];
        for (size_t i = 1; i < vi->size(); i++) {
            cur = std::max(cur, (*vi)[i]);
        }
        return qv_float(static_cast<double>(cur));
    }

    const std::vector<double>* vp = q_vec_f64_const(vec);
    if (!vp || vp->empty()) {
        return qv_null();
    }
    const std::vector<double>& v = *vp;
    double cur = v[0];
    for (size_t i = 1; i < v.size(); i++) {
        cur = std::max(cur, v[i]);
    }
    return qv_float(cur);
}

inline QValue q_fillna(QValue vec, QValue value) {
    if (!q_vec_has_valid_handle(vec) || !q_vec_validate(*vec.data.vector_val)) {
        return qv_null();
    }

    QVector& out = *vec.data.vector_val;
    if (!out.has_nulls || out.nulls.is_null.empty()) {
        return vec;
    }

    switch (out.type) {
        case QVector::Type::F64: {
            if (!q_is_numeric_scalar(value)) {
                return qv_null();
            }
            auto& values = std::get<std::vector<double>>(out.storage);
            const double fill = q_to_double_scalar(value);
            for (size_t i = 0; i < out.count; i++) {
                if (out.nulls.is_null[i] != 0) {
                    values[i] = fill;
                }
            }
            out.has_nulls = false;
            out.nulls.is_null.clear();
            return vec;
        }
        case QVector::Type::I64: {
            if (!(value.type == QValue::VAL_INT || value.type == QValue::VAL_FLOAT || value.type == QValue::VAL_BOOL)) {
                return qv_null();
            }
            auto& values = std::get<std::vector<int64_t>>(out.storage);
            const int64_t fill = q_to_i64_scalar(value);
            for (size_t i = 0; i < out.count; i++) {
                if (out.nulls.is_null[i] != 0) {
                    values[i] = fill;
                }
            }
            out.has_nulls = false;
            out.nulls.is_null.clear();
            return vec;
        }
        case QVector::Type::BOOL: {
            if (!q_is_boolish_scalar(value)) {
                return qv_null();
            }
            auto& values = std::get<std::vector<uint8_t>>(out.storage);
            const uint8_t fill = static_cast<uint8_t>((value.type == QValue::VAL_BOOL ? value.data.bool_val : (value.data.int_val != 0)) ? 1 : 0);
            for (size_t i = 0; i < out.count; i++) {
                if (out.nulls.is_null[i] != 0) {
                    values[i] = fill;
                }
            }
            out.has_nulls = false;
            out.nulls.is_null.clear();
            return vec;
        }
        case QVector::Type::STR: {
            if (value.type != QValue::VAL_STRING || value.data.string_val == nullptr) {
                return qv_null();
            }
            const auto& storage = std::get<QStringStorage>(out.storage);
            std::vector<std::string> values = q_vec_decode_strings(storage, out.count);
            const std::string fill(value.data.string_val);
            for (size_t i = 0; i < out.count; i++) {
                if (out.nulls.is_null[i] != 0) {
                    values[i] = fill;
                }
            }
            out.storage = q_vec_encode_strings(values);
            out.has_nulls = false;
            out.nulls.is_null.clear();
            return vec;
        }
        default:
            return qv_null();
    }
}

inline QValue q_astype(QValue vec, QValue dtype) {
    if (!q_vec_has_valid_handle(vec) || !q_vec_validate(*vec.data.vector_val)) {
        return qv_null();
    }
    if (dtype.type != QValue::VAL_STRING || dtype.data.string_val == nullptr) {
        return qv_null();
    }

    const QVector& src = *vec.data.vector_val;
    const char* target = dtype.data.string_val;

    if (std::strcmp(target, "f64") == 0) {
        if (src.type == QVector::Type::F64) {
            return q_vec_clone(vec);
        }
        QValue out = qv_vector(static_cast<int>(src.count));
        auto& outv = std::get<std::vector<double>>(out.data.vector_val->storage);
        outv.resize(src.count);
        out.data.vector_val->count = src.count;
        out.data.vector_val->has_nulls = src.has_nulls;
        out.data.vector_val->nulls = src.nulls;

        if (src.type == QVector::Type::I64) {
            const auto& in = std::get<std::vector<int64_t>>(src.storage);
            for (size_t i = 0; i < src.count; i++) outv[i] = static_cast<double>(in[i]);
            return out;
        }
        if (src.type == QVector::Type::BOOL) {
            const auto& in = std::get<std::vector<uint8_t>>(src.storage);
            for (size_t i = 0; i < src.count; i++) outv[i] = (in[i] != 0) ? 1.0 : 0.0;
            return out;
        }
        return qv_null();
    }

    if (std::strcmp(target, "i64") == 0) {
        if (src.type == QVector::Type::I64) {
            return q_vec_clone(vec);
        }
        QValue out = qv_vector_i64(static_cast<int>(src.count));
        auto& outv = std::get<std::vector<int64_t>>(out.data.vector_val->storage);
        outv.resize(src.count);
        out.data.vector_val->count = src.count;
        out.data.vector_val->has_nulls = src.has_nulls;
        out.data.vector_val->nulls = src.nulls;

        if (src.type == QVector::Type::F64) {
            const auto& in = std::get<std::vector<double>>(src.storage);
            for (size_t i = 0; i < src.count; i++) outv[i] = static_cast<int64_t>(in[i]);
            return out;
        }
        if (src.type == QVector::Type::BOOL) {
            const auto& in = std::get<std::vector<uint8_t>>(src.storage);
            for (size_t i = 0; i < src.count; i++) outv[i] = (in[i] != 0) ? 1 : 0;
            return out;
        }
        return qv_null();
    }

    if (std::strcmp(target, "bool") == 0) {
        if (src.type == QVector::Type::BOOL) {
            return q_vec_clone(vec);
        }
        QValue out = qv_vector_bool(static_cast<int>(src.count));
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        outv.resize(src.count);
        out.data.vector_val->count = src.count;
        out.data.vector_val->has_nulls = src.has_nulls;
        out.data.vector_val->nulls = src.nulls;

        if (src.type == QVector::Type::F64) {
            const auto& in = std::get<std::vector<double>>(src.storage);
            for (size_t i = 0; i < src.count; i++) outv[i] = static_cast<uint8_t>(in[i] != 0.0 ? 1 : 0);
            return out;
        }
        if (src.type == QVector::Type::I64) {
            const auto& in = std::get<std::vector<int64_t>>(src.storage);
            for (size_t i = 0; i < src.count; i++) outv[i] = static_cast<uint8_t>(in[i] != 0 ? 1 : 0);
            return out;
        }
        return qv_null();
    }

    return qv_null();
}

inline QValue q_to_vector(QValue input) {
    if (q_vec_has_valid_handle(input) && q_vec_validate(*input.data.vector_val)) {
        return q_vec_clone(input);
    }

    if (input.type != QValue::VAL_LIST || !input.data.list_val) {
        std::fprintf(stderr, "runtime error: to_vector expects list or vector input\n");
        return qv_null();
    }

    const QList& items = *input.data.list_val;
    const size_t n = items.size();

    enum class Mode { UNKNOWN, I64, F64, STR, INVALID };
    Mode mode = Mode::UNKNOWN;

    auto type_name = [](QValue::ValueType t) -> const char* {
        switch (t) {
            case QValue::VAL_INT: return "int";
            case QValue::VAL_FLOAT: return "float";
            case QValue::VAL_STRING: return "str";
            case QValue::VAL_BOOL: return "bool";
            case QValue::VAL_NULL: return "null";
            case QValue::VAL_LIST: return "list";
            case QValue::VAL_VECTOR: return "vector";
            case QValue::VAL_DICT: return "dict";
            case QValue::VAL_FUNC: return "func";
            case QValue::VAL_RESULT: return "result";
            default: return "unknown";
        }
    };

    for (size_t i = 0; i < n; i++) {
        const QValue& item = items[i];
        if (item.type == QValue::VAL_NULL) {
            continue;
        }

        switch (item.type) {
            case QValue::VAL_INT:
                if (mode == Mode::UNKNOWN) mode = Mode::I64;
                else if (mode != Mode::I64) mode = Mode::INVALID;
                break;
            case QValue::VAL_FLOAT:
                if (mode == Mode::UNKNOWN) mode = Mode::F64;
                else if (mode != Mode::F64) mode = Mode::INVALID;
                break;
                case QValue::VAL_STRING:
                    if (mode == Mode::UNKNOWN) mode = Mode::STR;
                    else if (mode != Mode::STR) mode = Mode::INVALID;
                    break;
            default:
                    std::fprintf(stderr, "runtime error: to_vector only supports int/float/str lists (null allowed), got %s at index %zu\n", type_name(item.type), i);
                mode = Mode::INVALID;
                break;
        }

        if (mode == Mode::INVALID) {
                if (item.type == QValue::VAL_INT || item.type == QValue::VAL_FLOAT || item.type == QValue::VAL_STRING) {
                    std::fprintf(stderr, "runtime error: to_vector requires homogeneous element types (all int, all float, or all str)\n");
            }
            return qv_null();
        }
    }

    if (mode == Mode::UNKNOWN) {
        mode = Mode::I64;
    }

    if (mode == Mode::F64) {
        QValue out = qv_vector(static_cast<int>(n));
        std::vector<double>& values = std::get<std::vector<double>>(out.data.vector_val->storage);
        values.resize(n, 0.0);
        out.data.vector_val->count = n;

        bool hasNulls = false;
        for (size_t i = 0; i < n; i++) {
            const QValue& item = items[i];
            if (item.type == QValue::VAL_NULL) {
                hasNulls = true;
                continue;
            }
            values[i] = item.data.float_val;
        }

        if (hasNulls) {
            q_vec_ensure_null_mask(*out.data.vector_val);
            for (size_t i = 0; i < n; i++) {
                if (items[i].type == QValue::VAL_NULL) {
                    out.data.vector_val->nulls.is_null[i] = 1;
                }
            }
        }
        return out;
    }

    if (mode == Mode::I64) {
        QValue out = qv_vector_i64(static_cast<int>(n));
        std::vector<int64_t>& values = std::get<std::vector<int64_t>>(out.data.vector_val->storage);
        values.resize(n, 0);
        out.data.vector_val->count = n;

        bool hasNulls = false;
        for (size_t i = 0; i < n; i++) {
            const QValue& item = items[i];
            if (item.type == QValue::VAL_NULL) {
                hasNulls = true;
                continue;
            }
            values[i] = static_cast<int64_t>(item.data.int_val);
        }

        if (hasNulls) {
            q_vec_ensure_null_mask(*out.data.vector_val);
            for (size_t i = 0; i < n; i++) {
                if (items[i].type == QValue::VAL_NULL) {
                    out.data.vector_val->nulls.is_null[i] = 1;
                }
            }
        }
        return out;
    }

    if (mode == Mode::STR) {
        std::vector<std::string> values(n);
        bool hasNulls = false;
        for (size_t i = 0; i < n; i++) {
            const QValue& item = items[i];
            if (item.type == QValue::VAL_NULL) {
                hasNulls = true;
                continue;
            }
            if (item.type != QValue::VAL_STRING || item.data.string_val == nullptr) {
                std::fprintf(stderr, "runtime error: to_vector requires homogeneous element types (all int, all float, or all str)\n");
                return qv_null();
            }
            values[i] = item.data.string_val;
        }

        QValue out = qv_vector_str(static_cast<int>(n), 0);
        out.data.vector_val->storage = q_vec_encode_strings(values);
        out.data.vector_val->count = n;

        if (hasNulls) {
            q_vec_ensure_null_mask(*out.data.vector_val);
            for (size_t i = 0; i < n; i++) {
                if (items[i].type == QValue::VAL_NULL) {
                    out.data.vector_val->nulls.is_null[i] = 1;
                }
            }
        }
        return out;
    }

    std::fprintf(stderr, "runtime error: to_vector could not determine output vector type\n");
    return qv_null();
}

// ============================================================
// Vector-to-List Conversion
// ============================================================

inline QValue q_to_list(QValue input) {
    // Identity: already a list
    if (input.type == QValue::VAL_LIST) {
        return input;
    }

    if (!q_vec_has_valid_handle(input)) {
        std::fprintf(stderr, "runtime error: to_list expects a vector or list input\n");
        return qv_null();
    }

    const QVector& v = *input.data.vector_val;
    const size_t n = v.count;
    QValue out = qv_list(static_cast<int>(n));
    QList& items = *out.data.list_val;
    items.reserve(n);

    for (size_t i = 0; i < n; i++) {
        // Check null mask
        if (v.has_nulls && i < v.nulls.is_null.size() && v.nulls.is_null[i]) {
            items.push_back(qv_null());
            continue;
        }

        switch (v.type) {
            case QVector::Type::I64: {
                const auto& vals = std::get<std::vector<int64_t>>(v.storage);
                items.push_back(qv_int(vals[i]));
                break;
            }
            case QVector::Type::F64: {
                const auto& vals = std::get<std::vector<double>>(v.storage);
                items.push_back(qv_float(vals[i]));
                break;
            }
            case QVector::Type::BOOL: {
                const auto& vals = std::get<std::vector<uint8_t>>(v.storage);
                items.push_back(qv_bool(vals[i] != 0));
                break;
            }
            case QVector::Type::STR: {
                auto strs = q_vec_decode_strings(std::get<QStringStorage>(v.storage), n);
                // Bulk add remaining strings from this point
                for (size_t j = i; j < n; j++) {
                    if (v.has_nulls && j < v.nulls.is_null.size() && v.nulls.is_null[j]) {
                        items.push_back(qv_null());
                    } else {
                        items.push_back(qv_string(q_strdup(strs[j].c_str())));
                    }
                }
                return out;
            }
        }
    }
    return out;
}

// ============================================================
// Vector Comparison Operations (output BOOL vectors)
// ============================================================

// Helper: build a BOOL output vector for a comparison result of size n.
// If either input has nulls, allocates the null mask on the output.
inline QValue q_vec_cmp_alloc_bool(size_t n, bool hasNulls) {
    QValue out = qv_vector_bool(static_cast<int>(n));
    auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
    outv.resize(n, 0);
    out.data.vector_val->count = n;
    if (hasNulls) {
        q_vec_ensure_null_mask(*out.data.vector_val);
    }
    return out;
}

// F64 comparison template: vec-vec, vec-scalar, scalar-vec  BOOL vector
template <typename CmpOp>
inline QValue q_vec_cmp_f64_impl(QValue a, QValue b, CmpOp op) {
    const bool aVec = q_vec_has_valid_handle(a);
    const bool bVec = q_vec_has_valid_handle(b);
    if (!aVec && !bVec) return qv_null();

    // vec-vec
    if (aVec && bVec) {
        const auto* avp = q_vec_f64_const(a);
        const auto* bvp = q_vec_f64_const(b);
        if (!avp || !bvp) return qv_null();
        const auto& av = *avp;
        const auto& bv = *bvp;
        if (av.size() != bv.size()) return qv_null();
        const size_t n = av.size();
        const bool aNull = a.data.vector_val->has_nulls;
        const bool bNull = b.data.vector_val->has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, aNull || bNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!aNull && !bNull) {
            for (size_t i = 0; i < n; i++) {
                outv[i] = static_cast<uint8_t>(op(av[i], bv[i]) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(*a.data.vector_val, i) || q_vec_is_null_at(*b.data.vector_val, i)) {
                    outNulls[i] = 1;
                } else {
                    outv[i] = static_cast<uint8_t>(op(av[i], bv[i]) ? 1 : 0);
                }
            }
        }
        return out;
    }

    // vec-scalar
    if (aVec && q_is_numeric_scalar(b)) {
        const auto* avp = q_vec_f64_const(a);
        if (!avp) return qv_null();
        const auto& av = *avp;
        const double bs = q_to_double_scalar(b);
        const size_t n = av.size();
        const bool aNull = a.data.vector_val->has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, aNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!aNull) {
            for (size_t i = 0; i < n; i++) {
                outv[i] = static_cast<uint8_t>(op(av[i], bs) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(*a.data.vector_val, i)) {
                    outNulls[i] = 1;
                } else {
                    outv[i] = static_cast<uint8_t>(op(av[i], bs) ? 1 : 0);
                }
            }
        }
        return out;
    }

    // scalar-vec
    if (bVec && q_is_numeric_scalar(a)) {
        const auto* bvp = q_vec_f64_const(b);
        if (!bvp) return qv_null();
        const auto& bv = *bvp;
        const double as = q_to_double_scalar(a);
        const size_t n = bv.size();
        const bool bNull = b.data.vector_val->has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, bNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!bNull) {
            for (size_t i = 0; i < n; i++) {
                outv[i] = static_cast<uint8_t>(op(as, bv[i]) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(*b.data.vector_val, i)) {
                    outNulls[i] = 1;
                } else {
                    outv[i] = static_cast<uint8_t>(op(as, bv[i]) ? 1 : 0);
                }
            }
        }
        return out;
    }

    return qv_null();
}

// I64 comparison template: vec-vec, vec-scalar, scalar-vec  BOOL vector
template <typename CmpOp>
inline QValue q_vec_cmp_i64_impl(QValue a, QValue b, CmpOp op) {
    const bool aVec = q_vec_has_valid_handle(a);
    const bool bVec = q_vec_has_valid_handle(b);

    // vec-vec
    if (aVec && bVec) {
        const auto* avp = q_vec_i64_const(a);
        const auto* bvp = q_vec_i64_const(b);
        if (!avp || !bvp || avp->size() != bvp->size()) return qv_null();
        const size_t n = avp->size();
        const bool aNull = a.data.vector_val->has_nulls;
        const bool bNull = b.data.vector_val->has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, aNull || bNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!aNull && !bNull) {
            for (size_t i = 0; i < n; i++) {
                outv[i] = static_cast<uint8_t>(op((*avp)[i], (*bvp)[i]) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(*a.data.vector_val, i) || q_vec_is_null_at(*b.data.vector_val, i)) {
                    outNulls[i] = 1;
                } else {
                    outv[i] = static_cast<uint8_t>(op((*avp)[i], (*bvp)[i]) ? 1 : 0);
                }
            }
        }
        return out;
    }

    // vec-scalar
    if (aVec && q_is_integral_scalar(b)) {
        const auto* avp = q_vec_i64_const(a);
        if (!avp) return qv_null();
        const int64_t bs = q_to_i64_scalar(b);
        const size_t n = avp->size();
        const bool aNull = a.data.vector_val->has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, aNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!aNull) {
            for (size_t i = 0; i < n; i++) {
                outv[i] = static_cast<uint8_t>(op((*avp)[i], bs) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(*a.data.vector_val, i)) {
                    outNulls[i] = 1;
                } else {
                    outv[i] = static_cast<uint8_t>(op((*avp)[i], bs) ? 1 : 0);
                }
            }
        }
        return out;
    }

    // scalar-vec
    if (bVec && q_is_integral_scalar(a)) {
        const auto* bvp = q_vec_i64_const(b);
        if (!bvp) return qv_null();
        const int64_t as = q_to_i64_scalar(a);
        const size_t n = bvp->size();
        const bool bNull = b.data.vector_val->has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, bNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!bNull) {
            for (size_t i = 0; i < n; i++) {
                outv[i] = static_cast<uint8_t>(op(as, (*bvp)[i]) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(*b.data.vector_val, i)) {
                    outNulls[i] = 1;
                } else {
                    outv[i] = static_cast<uint8_t>(op(as, (*bvp)[i]) ? 1 : 0);
                }
            }
        }
        return out;
    }

    return qv_null();
}

// BOOL comparison template: vec-vec or vec-scalar  BOOL vector (eq/neq only)
template <typename CmpOp>
inline QValue q_vec_cmp_bool_impl(QValue a, QValue b, CmpOp op) {
    const bool aVec = q_vec_is_type(a, QVector::Type::BOOL);
    const bool bVec = q_vec_is_type(b, QVector::Type::BOOL);

    if (aVec && bVec) {
        const auto& av = *q_vec_bool_const(a);
        const auto& bv = *q_vec_bool_const(b);
        if (av.size() != bv.size()) return qv_null();
        const size_t n = av.size();
        const bool aNull = a.data.vector_val->has_nulls;
        const bool bNull = b.data.vector_val->has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, aNull || bNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!aNull && !bNull) {
            for (size_t i = 0; i < n; i++) {
                outv[i] = static_cast<uint8_t>(op(av[i] != 0, bv[i] != 0) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(*a.data.vector_val, i) || q_vec_is_null_at(*b.data.vector_val, i)) {
                    outNulls[i] = 1;
                } else {
                    outv[i] = static_cast<uint8_t>(op(av[i] != 0, bv[i] != 0) ? 1 : 0);
                }
            }
        }
        return out;
    }

    // BOOL vec vs bool scalar
    if (aVec && (b.type == QValue::VAL_BOOL || b.type == QValue::VAL_INT)) {
        const auto& av = *q_vec_bool_const(a);
        const bool bs = (b.type == QValue::VAL_BOOL) ? b.data.bool_val : (b.data.int_val != 0);
        const size_t n = av.size();
        const bool aNull = a.data.vector_val->has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, aNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!aNull) {
            for (size_t i = 0; i < n; i++) {
                outv[i] = static_cast<uint8_t>(op(av[i] != 0, bs) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(*a.data.vector_val, i)) {
                    outNulls[i] = 1;
                } else {
                    outv[i] = static_cast<uint8_t>(op(av[i] != 0, bs) ? 1 : 0);
                }
            }
        }
        return out;
    }

    // bool scalar vs BOOL vec
    if (bVec && (a.type == QValue::VAL_BOOL || a.type == QValue::VAL_INT)) {
        const auto& bv = *q_vec_bool_const(b);
        const bool as = (a.type == QValue::VAL_BOOL) ? a.data.bool_val : (a.data.int_val != 0);
        const size_t n = bv.size();
        const bool bNull = b.data.vector_val->has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, bNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!bNull) {
            for (size_t i = 0; i < n; i++) {
                outv[i] = static_cast<uint8_t>(op(as, bv[i] != 0) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(*b.data.vector_val, i)) {
                    outNulls[i] = 1;
                } else {
                    outv[i] = static_cast<uint8_t>(op(as, bv[i] != 0) ? 1 : 0);
                }
            }
        }
        return out;
    }

    return qv_null();
}

// STR equality: vec-vec or vec-scalar  BOOL vector
inline QValue q_vec_cmp_str_eq(QValue a, QValue b, bool negate) {
    const bool aStr = q_vec_is_type(a, QVector::Type::STR);
    const bool bStr = q_vec_is_type(b, QVector::Type::STR);

    // STR vec vs STR vec
    if (aStr && bStr) {
        const QVector& av = *a.data.vector_val;
        const QVector& bv = *b.data.vector_val;
        if (av.count != bv.count) return qv_null();
        const size_t n = av.count;
        auto aStrs = q_vec_decode_strings(std::get<QStringStorage>(av.storage), n);
        auto bStrs = q_vec_decode_strings(std::get<QStringStorage>(bv.storage), n);
        const bool aNull = av.has_nulls;
        const bool bNull = bv.has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, aNull || bNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!aNull && !bNull) {
            for (size_t i = 0; i < n; i++) {
                bool eq = (aStrs[i] == bStrs[i]);
                outv[i] = static_cast<uint8_t>((negate ? !eq : eq) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(av, i) || q_vec_is_null_at(bv, i)) {
                    outNulls[i] = 1;
                } else {
                    bool eq = (aStrs[i] == bStrs[i]);
                    outv[i] = static_cast<uint8_t>((negate ? !eq : eq) ? 1 : 0);
                }
            }
        }
        return out;
    }

    // STR vec vs scalar string
    if (aStr && b.type == QValue::VAL_STRING && b.data.string_val) {
        const QVector& av = *a.data.vector_val;
        const size_t n = av.count;
        auto aStrs = q_vec_decode_strings(std::get<QStringStorage>(av.storage), n);
        const std::string scalar(b.data.string_val);
        const bool aNull = av.has_nulls;
        QValue out = q_vec_cmp_alloc_bool(n, aNull);
        auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
        if (!aNull) {
            for (size_t i = 0; i < n; i++) {
                bool eq = (aStrs[i] == scalar);
                outv[i] = static_cast<uint8_t>((negate ? !eq : eq) ? 1 : 0);
            }
        } else {
            auto& outNulls = out.data.vector_val->nulls.is_null;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(av, i)) {
                    outNulls[i] = 1;
                } else {
                    bool eq = (aStrs[i] == scalar);
                    outv[i] = static_cast<uint8_t>((negate ? !eq : eq) ? 1 : 0);
                }
            }
        }
        return out;
    }

    // scalar string vs STR vec
    if (bStr && a.type == QValue::VAL_STRING && a.data.string_val) {
        // Swap and reuse: eq is symmetric, neq is symmetric
        return q_vec_cmp_str_eq(b, a, negate);
    }

    return qv_null();
}

// ---- Dispatch functions (called from comparison.hpp) ----

inline QValue q_vec_lt(QValue a, QValue b) {
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_cmp_i64_impl(a, b, [](int64_t x, int64_t y) { return x < y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    QValue out = q_vec_cmp_f64_impl(a, b, [](double x, double y) { return x < y; });
    if (out.type != QValue::VAL_NULL) return out;
    std::fprintf(stderr, "runtime error: operator '<' not supported for these vector types\n");
    return qv_null();
}

inline QValue q_vec_lte(QValue a, QValue b) {
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_cmp_i64_impl(a, b, [](int64_t x, int64_t y) { return x <= y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    QValue out = q_vec_cmp_f64_impl(a, b, [](double x, double y) { return x <= y; });
    if (out.type != QValue::VAL_NULL) return out;
    std::fprintf(stderr, "runtime error: operator '<=' not supported for these vector types\n");
    return qv_null();
}

inline QValue q_vec_gt(QValue a, QValue b) {
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_cmp_i64_impl(a, b, [](int64_t x, int64_t y) { return x > y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    QValue out = q_vec_cmp_f64_impl(a, b, [](double x, double y) { return x > y; });
    if (out.type != QValue::VAL_NULL) return out;
    std::fprintf(stderr, "runtime error: operator '>' not supported for these vector types\n");
    return qv_null();
}

inline QValue q_vec_gte(QValue a, QValue b) {
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_cmp_i64_impl(a, b, [](int64_t x, int64_t y) { return x >= y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    QValue out = q_vec_cmp_f64_impl(a, b, [](double x, double y) { return x >= y; });
    if (out.type != QValue::VAL_NULL) return out;
    std::fprintf(stderr, "runtime error: operator '>=' not supported for these vector types\n");
    return qv_null();
}

inline QValue q_vec_eq(QValue a, QValue b) {
    // Try numeric paths first
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_cmp_i64_impl(a, b, [](int64_t x, int64_t y) { return x == y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    {
        QValue out = q_vec_cmp_f64_impl(a, b, [](double x, double y) { return x == y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    // BOOL equality
    {
        QValue out = q_vec_cmp_bool_impl(a, b, [](bool x, bool y) { return x == y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    // STR equality
    {
        QValue out = q_vec_cmp_str_eq(a, b, false);
        if (out.type != QValue::VAL_NULL) return out;
    }
    std::fprintf(stderr, "runtime error: operator '==' not supported for these vector types\n");
    return qv_null();
}

inline QValue q_vec_neq(QValue a, QValue b) {
    // Try numeric paths first
    if (q_vec_is_type(a, QVector::Type::I64) || q_vec_is_type(b, QVector::Type::I64)) {
        QValue out = q_vec_cmp_i64_impl(a, b, [](int64_t x, int64_t y) { return x != y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    {
        QValue out = q_vec_cmp_f64_impl(a, b, [](double x, double y) { return x != y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    // BOOL inequality
    {
        QValue out = q_vec_cmp_bool_impl(a, b, [](bool x, bool y) { return x != y; });
        if (out.type != QValue::VAL_NULL) return out;
    }
    // STR inequality
    {
        QValue out = q_vec_cmp_str_eq(a, b, true);
        if (out.type != QValue::VAL_NULL) return out;
    }
    std::fprintf(stderr, "runtime error: operator '!=' not supported for these vector types\n");
    return qv_null();
}

// ============================================================
// Vector Scalar Indexing & Boolean Mask Filtering
// ============================================================

// Scalar integer index on a vector: vec[i]  boxed QValue
inline QValue q_vec_get_scalar(QValue vec, QValue index) {
    if (!q_vec_has_valid_handle(vec)) return qv_null();
    if (index.type != QValue::VAL_INT) return qv_null();

    const QVector& v = *vec.data.vector_val;
    int idx = static_cast<int>(index.data.int_val);
    int len = static_cast<int>(v.count);
    if (idx < 0) idx = len + idx;
    if (idx < 0 || idx >= len) return qv_null();
    const size_t i = static_cast<size_t>(idx);

    if (q_vec_is_null_at(v, i)) return qv_null();

    switch (v.type) {
        case QVector::Type::F64:
            return qv_float(std::get<std::vector<double>>(v.storage)[i]);
        case QVector::Type::I64:
            return qv_int(std::get<std::vector<int64_t>>(v.storage)[i]);
        case QVector::Type::BOOL:
            return qv_bool(std::get<std::vector<uint8_t>>(v.storage)[i] != 0);
        case QVector::Type::STR: {
            const auto& s = std::get<QStringStorage>(v.storage);
            uint32_t start = s.offsets[i];
            uint32_t end = s.offsets[i + 1];
            std::string elem(s.bytes.data() + start, s.bytes.data() + end);
            return qv_string(elem.c_str());
        }
        default:
            return qv_null();
    }
}

// Boolean mask filter: data[mask]  new vector with matching elements
inline QValue q_vec_mask_filter(QValue data, QValue mask) {
    if (!q_vec_has_valid_handle(data) || !q_vec_has_valid_handle(mask)) {
        return qv_null();
    }
    const QVector& dv = *data.data.vector_val;
    const QVector& mv = *mask.data.vector_val;

    if (mv.type != QVector::Type::BOOL) {
        std::fprintf(stderr, "runtime error: mask index must be a bool vector, got vector[%s]\n",
                     q_vec_dtype_name(mv));
        return qv_null();
    }
    if (dv.count != mv.count) {
        std::fprintf(stderr, "runtime error: mask length (%zu) does not match vector length (%zu)\n",
                     mv.count, dv.count);
        return qv_null();
    }

    const auto& maskBits = std::get<std::vector<uint8_t>>(mv.storage);
    const size_t n = dv.count;

    // Count selected elements (mask=1 and mask not null)
    size_t selected = 0;
    for (size_t i = 0; i < n; i++) {
        if (!q_vec_is_null_at(mv, i) && maskBits[i] != 0) selected++;
    }

    switch (dv.type) {
        case QVector::Type::F64: {
            QValue out = qv_vector(static_cast<int>(selected));
            auto& outv = std::get<std::vector<double>>(out.data.vector_val->storage);
            outv.reserve(selected);
            out.data.vector_val->count = 0;
            bool hasNulls = false;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(mv, i) || maskBits[i] == 0) continue;
                outv.push_back(std::get<std::vector<double>>(dv.storage)[i]);
                if (q_vec_is_null_at(dv, i)) hasNulls = true;
            }
            out.data.vector_val->count = outv.size();
            if (hasNulls) {
                q_vec_ensure_null_mask(*out.data.vector_val);
                size_t j = 0;
                for (size_t i = 0; i < n; i++) {
                    if (q_vec_is_null_at(mv, i) || maskBits[i] == 0) continue;
                    if (q_vec_is_null_at(dv, i)) {
                        out.data.vector_val->nulls.is_null[j] = 1;
                    }
                    j++;
                }
            }
            return out;
        }
        case QVector::Type::I64: {
            QValue out = qv_vector_i64(static_cast<int>(selected));
            auto& outv = std::get<std::vector<int64_t>>(out.data.vector_val->storage);
            outv.reserve(selected);
            out.data.vector_val->count = 0;
            bool hasNulls = false;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(mv, i) || maskBits[i] == 0) continue;
                outv.push_back(std::get<std::vector<int64_t>>(dv.storage)[i]);
                if (q_vec_is_null_at(dv, i)) hasNulls = true;
            }
            out.data.vector_val->count = outv.size();
            if (hasNulls) {
                q_vec_ensure_null_mask(*out.data.vector_val);
                size_t j = 0;
                for (size_t i = 0; i < n; i++) {
                    if (q_vec_is_null_at(mv, i) || maskBits[i] == 0) continue;
                    if (q_vec_is_null_at(dv, i)) {
                        out.data.vector_val->nulls.is_null[j] = 1;
                    }
                    j++;
                }
            }
            return out;
        }
        case QVector::Type::BOOL: {
            QValue out = qv_vector_bool(static_cast<int>(selected));
            auto& outv = std::get<std::vector<uint8_t>>(out.data.vector_val->storage);
            outv.reserve(selected);
            out.data.vector_val->count = 0;
            bool hasNulls = false;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(mv, i) || maskBits[i] == 0) continue;
                outv.push_back(std::get<std::vector<uint8_t>>(dv.storage)[i]);
                if (q_vec_is_null_at(dv, i)) hasNulls = true;
            }
            out.data.vector_val->count = outv.size();
            if (hasNulls) {
                q_vec_ensure_null_mask(*out.data.vector_val);
                size_t j = 0;
                for (size_t i = 0; i < n; i++) {
                    if (q_vec_is_null_at(mv, i) || maskBits[i] == 0) continue;
                    if (q_vec_is_null_at(dv, i)) {
                        out.data.vector_val->nulls.is_null[j] = 1;
                    }
                    j++;
                }
            }
            return out;
        }
        case QVector::Type::STR: {
            // Decode, filter, re-encode
            auto strs = q_vec_decode_strings(std::get<QStringStorage>(dv.storage), n);
            std::vector<std::string> filtered;
            filtered.reserve(selected);
            std::vector<uint8_t> filteredNulls;
            bool hasNulls = false;
            for (size_t i = 0; i < n; i++) {
                if (q_vec_is_null_at(mv, i) || maskBits[i] == 0) continue;
                filtered.push_back(strs[i]);
                bool isNull = q_vec_is_null_at(dv, i);
                filteredNulls.push_back(isNull ? 1 : 0);
                if (isNull) hasNulls = true;
            }
            QValue out = qv_vector_str(static_cast<int>(filtered.size()), 0);
            out.data.vector_val->storage = q_vec_encode_strings(filtered);
            out.data.vector_val->count = filtered.size();
            if (hasNulls) {
                out.data.vector_val->has_nulls = true;
                out.data.vector_val->nulls.is_null = filteredNulls;
            }
            return out;
        }
        default:
            return qv_null();
    }
}

// ============================================================
// types/list.hpp
// ============================================================

// quark/types/list.hpp - List operations using std::vector
// Push item to end of list
inline QValue q_push(QValue list, QValue item) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    list.data.list_val->push_back(item);
    return list;
}

// Pop item from end of list
inline QValue q_pop(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val || list.data.list_val->empty()) {
        return qv_null();
    }
    QValue item = list.data.list_val->back();
    list.data.list_val->pop_back();
    return item;
}

// Get item at index (supports negative indexing)
inline QValue q_get(QValue list, QValue index) {
    if (list.type == QValue::VAL_STRING) {
        return q_str_get(list, index);
    }
    // Vector indexing: scalar int or boolean mask
    if (list.type == QValue::VAL_VECTOR) {
        if (index.type == QValue::VAL_INT) {
            return q_vec_get_scalar(list, index);
        }
        if (index.type == QValue::VAL_VECTOR) {
            return q_vec_mask_filter(list, index);
        }
        std::fprintf(stderr, "runtime error: vector index must be int or bool vector\n");
        return qv_null();
    }
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }
    int idx = static_cast<int>(index.data.int_val);
    int len = static_cast<int>(list.data.list_val->size());
    if (idx < 0) idx = len + idx;
    if (idx < 0 || idx >= len) {
        return qv_null();
    }
    return (*list.data.list_val)[idx];
}

// Set item at index (supports negative indexing)
inline QValue q_set(QValue list, QValue index, QValue value) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }
    int idx = static_cast<int>(index.data.int_val);
    int len = static_cast<int>(list.data.list_val->size());
    if (idx < 0) idx = len + idx;
    if (idx < 0 || idx >= len) {
        return qv_null();
    }
    (*list.data.list_val)[idx] = value;
    return value;
}

// Get list size
inline int q_list_size(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return 0;
    }
    return static_cast<int>(list.data.list_val->size());
}

// Check if list is empty
inline bool q_list_empty(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return true;
    }
    return list.data.list_val->empty();
}

// Clear all items from list
inline QValue q_list_clear(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    list.data.list_val->clear();
    return list;
}

// Insert item at index
inline QValue q_insert(QValue list, QValue index, QValue item) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    // Type guard: index must be INT
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }
    int idx = static_cast<int>(index.data.int_val);
    int len = static_cast<int>(list.data.list_val->size());
    if (idx < 0) idx = len + idx;
    if (idx < 0) idx = 0;
    if (idx > len) idx = len;
    list.data.list_val->insert(list.data.list_val->begin() + idx, item);
    return list;
}

// Remove item at index
inline QValue q_remove(QValue list, QValue index) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    // Type guard: index must be INT
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }
    int idx = static_cast<int>(index.data.int_val);
    int len = static_cast<int>(list.data.list_val->size());
    if (idx < 0) idx = len + idx;
    if (idx < 0 || idx >= len) {
        return qv_null();
    }
    QValue item = (*list.data.list_val)[idx];
    list.data.list_val->erase(list.data.list_val->begin() + idx);
    return item;
}

// Concatenate two lists, returns new list
inline QValue q_list_concat(QValue a, QValue b) {
    if (a.type != QValue::VAL_LIST || b.type != QValue::VAL_LIST) {
        return qv_null();
    }
    QValue result = qv_list();
    if (a.data.list_val) {
        for (const auto& item : *a.data.list_val) {
            result.data.list_val->push_back(item);
        }
    }
    if (b.data.list_val) {
        for (const auto& item : *b.data.list_val) {
            result.data.list_val->push_back(item);
        }
    }
    return result;
}

// Unified concat - dispatches to string or list concat at runtime
inline QValue q_concat(QValue a, QValue b) {
    if (a.type == QValue::VAL_STRING && b.type == QValue::VAL_STRING) {
        return q_str_concat(a, b);
    }
    if (a.type == QValue::VAL_LIST && b.type == QValue::VAL_LIST) {
        return q_list_concat(a, b);
    }
    // Type mismatch - both arguments must be the same type
    const char* type_names[] = {"int", "float", "string", "bool", "null", "list", "vector", "dict", "func", "result"};
    const char* a_type = (a.type >= 0 && a.type <= 8) ? type_names[a.type] : "unknown";
    const char* b_type = (b.type >= 0 && b.type <= 8) ? type_names[b.type] : "unknown";
    fprintf(stderr, "runtime error: concat expects both arguments to be the same type (string+string or list+list), got %s and %s\n", a_type, b_type);
    return qv_null();
}

// Slice list [start:end), returns new list
inline QValue q_slice(QValue list, QValue start, QValue end) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    // Type guard: start and end must be INT
    if (start.type != QValue::VAL_INT || end.type != QValue::VAL_INT) {
        return qv_null();
    }
    int len = static_cast<int>(list.data.list_val->size());
    int s = static_cast<int>(start.data.int_val);
    int e = static_cast<int>(end.data.int_val);

    // Handle negative indices
    if (s < 0) s = len + s;
    if (e < 0) e = len + e;

    // Clamp to bounds
    if (s < 0) s = 0;
    if (e > len) e = len;
    if (s >= e) return qv_list();

    QValue result = qv_list(e - s);
    for (int i = s; i < e; i++) {
        result.data.list_val->push_back((*list.data.list_val)[i]);
    }
    return result;
}

// Reverse list in place
inline QValue q_reverse(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    std::reverse(list.data.list_val->begin(), list.data.list_val->end());
    return list;
}

// Free list memory (for manual cleanup if needed)
inline void q_list_free(QValue list) {
    if (list.type == QValue::VAL_LIST && list.data.list_val) {
        delete list.data.list_val;
    }
}

// Range functions - generate lists of integers
// range(end) - generates [0, 1, 2, ..., end-1]
inline QValue q_range(QValue end) {
    long long e = 0;
    if (end.type == QValue::VAL_INT) {
        e = end.data.int_val;
    } else if (end.type == QValue::VAL_FLOAT) {
        e = static_cast<long long>(end.data.float_val);
    } else {
        return qv_list();
    }

    QValue result = qv_list();
    for (long long i = 0; i < e; i++) {
        result.data.list_val->push_back(qv_int(i));
    }
    return result;
}

// range(start, end) - generates [start, start+1, ..., end-1]
inline QValue q_range(QValue start, QValue end) {
    long long s = 0, e = 0;

    if (start.type == QValue::VAL_INT) {
        s = start.data.int_val;
    } else if (start.type == QValue::VAL_FLOAT) {
        s = static_cast<long long>(start.data.float_val);
    } else {
        return qv_list();
    }

    if (end.type == QValue::VAL_INT) {
        e = end.data.int_val;
    } else if (end.type == QValue::VAL_FLOAT) {
        e = static_cast<long long>(end.data.float_val);
    } else {
        return qv_list();
    }

    QValue result = qv_list();
    if (s < e) {
        for (long long i = s; i < e; i++) {
            result.data.list_val->push_back(qv_int(i));
        }
    } else {
        for (long long i = s; i > e; i--) {
            result.data.list_val->push_back(qv_int(i));
        }
    }
    return result;
}

// range(start, end, step) - generates [start, start+step, start+2*step, ...]
inline QValue q_range(QValue start, QValue end, QValue step) {
    long long s = 0, e = 0, st = 1;

    if (start.type == QValue::VAL_INT) {
        s = start.data.int_val;
    } else if (start.type == QValue::VAL_FLOAT) {
        s = static_cast<long long>(start.data.float_val);
    } else {
        return qv_list();
    }

    if (end.type == QValue::VAL_INT) {
        e = end.data.int_val;
    } else if (end.type == QValue::VAL_FLOAT) {
        e = static_cast<long long>(end.data.float_val);
    } else {
        return qv_list();
    }

    if (step.type == QValue::VAL_INT) {
        st = step.data.int_val;
    } else if (step.type == QValue::VAL_FLOAT) {
        st = static_cast<long long>(step.data.float_val);
    } else {
        return qv_list();
    }

    if (st == 0) {
        return qv_list(); // Avoid infinite loop
    }

    QValue result = qv_list();
    if (st > 0) {
        for (long long i = s; i < e; i += st) {
            result.data.list_val->push_back(qv_int(i));
        }
    } else {
        for (long long i = s; i > e; i += st) {
            result.data.list_val->push_back(qv_int(i));
        }
    }
    return result;
}

// ============================================================
// types/function.hpp
// ============================================================

// quark/types/function.hpp - Function value operations
#include <cstdio>

inline bool q_require_callable(const QValue& f) {
    if (f.type == QValue::VAL_FUNC) {
        return true;
    }
    std::fprintf(stderr, "runtime error: attempted to call a non-function value\n");
    return false;
}

// Call function value with 0 arguments
inline QValue q_call0(QValue f) {
    if (!q_require_callable(f)) return qv_null();
    QClosure* cl = static_cast<QClosure*>(f.data.func_val);
    return reinterpret_cast<QClFunc0>(cl->func)(cl);
}

// Call function value with 1 argument
inline QValue q_call1(QValue f, QValue a) {
    if (!q_require_callable(f)) return qv_null();
    QClosure* cl = static_cast<QClosure*>(f.data.func_val);
    return reinterpret_cast<QClFunc1>(cl->func)(cl, a);
}

// Call function value with 2 arguments
inline QValue q_call2(QValue f, QValue a, QValue b) {
    if (!q_require_callable(f)) return qv_null();
    QClosure* cl = static_cast<QClosure*>(f.data.func_val);
    return reinterpret_cast<QClFunc2>(cl->func)(cl, a, b);
}

// Call function value with 3 arguments
inline QValue q_call3(QValue f, QValue a, QValue b, QValue c) {
    if (!q_require_callable(f)) return qv_null();
    QClosure* cl = static_cast<QClosure*>(f.data.func_val);
    return reinterpret_cast<QClFunc3>(cl->func)(cl, a, b, c);
}

// Call function value with 4 arguments
inline QValue q_call4(QValue f, QValue a, QValue b, QValue c, QValue d) {
    if (!q_require_callable(f)) return qv_null();
    QClosure* cl = static_cast<QClosure*>(f.data.func_val);
    return reinterpret_cast<QClFunc4>(cl->func)(cl, a, b, c, d);
}

// ============================================================
// core/truthy.hpp
// ============================================================

// quark/core/truthy.hpp - Truthiness checking
#include <cstring>

// Check if a value is truthy (used for conditions)
inline bool q_truthy(QValue v) {
    switch (v.type) {
        case QValue::VAL_BOOL:
            return v.data.bool_val;
        case QValue::VAL_INT:
            return v.data.int_val != 0;
        case QValue::VAL_FLOAT:
            return v.data.float_val != 0.0;
        case QValue::VAL_STRING:
            return v.data.string_val != nullptr && strlen(v.data.string_val) > 0;
        case QValue::VAL_NULL:
            return false;
        case QValue::VAL_LIST:
            return v.data.list_val && !v.data.list_val->empty();
        case QValue::VAL_VECTOR:
            return q_vec_size(v) > 0;
        case QValue::VAL_DICT:
            return v.data.dict_val && !v.data.dict_val->entries.empty();
        case QValue::VAL_FUNC:
            return v.data.func_val != nullptr;
        case QValue::VAL_RESULT:
            return v.data.result_val && v.data.result_val->is_ok;
        default:
            return false;
    }
}

// ============================================================
// ops/arithmetic.hpp
// ============================================================

// quark/ops/arithmetic.hpp - Arithmetic operations
#include <cstdio>
#include <cmath>
#include <climits>

namespace quark {
namespace detail {

// Helper to extract numeric value as double
#ifndef QUARK_DETAIL_TO_DOUBLE_DEFINED
#define QUARK_DETAIL_TO_DOUBLE_DEFINED
inline double to_double(const QValue& v) {
    return v.type == QValue::VAL_FLOAT ? v.data.float_val
                                       : static_cast<double>(v.data.int_val);
}

inline bool either_float(const QValue& a, const QValue& b) {
    return a.type == QValue::VAL_FLOAT || b.type == QValue::VAL_FLOAT;
}
#endif

} // namespace detail
} // namespace quark

inline const char* q_type_name_arith(QValue::ValueType t) {
    static const char* type_names[] = {"int", "float", "str", "bool", "null", "list", "vector", "dict", "func", "result"};
    return (t >= 0 && t <= 9) ? type_names[t] : "unknown";
}

inline void q_arith_type_error(const char* op, QValue a, QValue b) {
    std::fprintf(stderr, "runtime error: operator '%s' expects numeric operands (or str+str for '+'), got %s and %s\n", op, q_type_name_arith(a.type), q_type_name_arith(b.type));
}

inline void q_unary_type_error(const char* op, QValue a) {
    std::fprintf(stderr, "runtime error: unary operator '%s' expects numeric operand, got %s\n", op, q_type_name_arith(a.type));
}

// Addition: int + int = int, float promotion, string + string = concat
inline QValue q_add(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_add(a, b);
    }
    // String concatenation: string + string
    if (a.type == QValue::VAL_STRING && b.type == QValue::VAL_STRING) {
        if (!a.data.string_val || !b.data.string_val) return qv_null();
        size_t alen = strlen(a.data.string_val);
        size_t blen = strlen(b.data.string_val);
        char* result = static_cast<char*>(q_malloc_atomic(alen + blen + 1));
        if (!result) return qv_null();
        memcpy(result, a.data.string_val, alen);
        memcpy(result + alen, b.data.string_val, blen);
        result[alen + blen] = '\0';
        QValue q;
        q.type = QValue::VAL_STRING;
        q.data.string_val = result;
        return q;
    }
    // Type guard: only INT and FLOAT are valid for numeric addition
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        q_arith_type_error("+", a, b);
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_float(quark::detail::to_double(a) + quark::detail::to_double(b));
    }
    return qv_int(a.data.int_val + b.data.int_val);
}

// Subtraction: int - int = int, otherwise float
inline QValue q_sub(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_sub(a, b);
    }
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        q_arith_type_error("-", a, b);
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_float(quark::detail::to_double(a) - quark::detail::to_double(b));
    }
    return qv_int(a.data.int_val - b.data.int_val);
}

// Multiplication: int * int = int, otherwise float
inline QValue q_mul(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_mul(a, b);
    }
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        q_arith_type_error("*", a, b);
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_float(quark::detail::to_double(a) * quark::detail::to_double(b));
    }
    return qv_int(a.data.int_val * b.data.int_val);
}

// Division: always returns float for precision
inline QValue q_div(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_div(a, b);
    }
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        q_arith_type_error("/", a, b);
        return qv_null();
    }
    double bv = quark::detail::to_double(b);
    // Check for division by zero
    if (bv == 0.0) {
        std::fprintf(stderr, "runtime error: division by zero\n");
        return qv_null();
    }
    return qv_float(quark::detail::to_double(a) / bv);
}

// Modulo: integer only
inline QValue q_mod(QValue a, QValue b) {
    // Type guard: only INT is valid for modulo
    if (a.type != QValue::VAL_INT || b.type != QValue::VAL_INT) {
        std::fprintf(stderr, "runtime error: operator '%%' expects int operands, got %s and %s\n", q_type_name_arith(a.type), q_type_name_arith(b.type));
        return qv_null();
    }
    // Check for modulo by zero
    if (b.data.int_val == 0) {
        std::fprintf(stderr, "runtime error: modulo by zero\n");
        return qv_null();
    }
    return qv_int(a.data.int_val % b.data.int_val);
}

// Power: preserves int type when possible
inline QValue q_pow(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        q_arith_type_error("**", a, b);
        return qv_null();
    }
    double av = quark::detail::to_double(a);
    double bv = quark::detail::to_double(b);
    double result = std::pow(av, bv);

    if (quark::detail::either_float(a, b)) {
        return qv_float(result);
    }
    // Overflow guard: if result exceeds long long range, return as float
    if (result > static_cast<double>(LLONG_MAX) || result < static_cast<double>(LLONG_MIN) ||
        std::isnan(result) || std::isinf(result)) {
        return qv_float(result);
    }
    return qv_int(static_cast<long long>(result));
}

// Unary negation
inline QValue q_neg(QValue a) {
    // Type guard: only INT and FLOAT are valid
    if (a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) {
        q_unary_type_error("-", a);
        return qv_null();
    }
    if (a.type == QValue::VAL_FLOAT) {
        return qv_float(-a.data.float_val);
    }
    return qv_int(-a.data.int_val);
}

// ============================================================
// ops/comparison.hpp
// ============================================================

// quark/ops/comparison.hpp - Comparison operations
#include <cstring>

// Helper functions to_double() and either_float() are defined in arithmetic.hpp
// (removed from here to avoid duplication in the concatenated runtime.hpp)

// Less than
inline QValue q_lt(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_lt(a, b);
    }
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_bool(quark::detail::to_double(a) < quark::detail::to_double(b));
    }
    return qv_bool(a.data.int_val < b.data.int_val);
}

// Less than or equal
inline QValue q_lte(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_lte(a, b);
    }
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_bool(quark::detail::to_double(a) <= quark::detail::to_double(b));
    }
    return qv_bool(a.data.int_val <= b.data.int_val);
}

// Greater than
inline QValue q_gt(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_gt(a, b);
    }
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_bool(quark::detail::to_double(a) > quark::detail::to_double(b));
    }
    return qv_bool(a.data.int_val > b.data.int_val);
}

// Greater than or equal
inline QValue q_gte(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_gte(a, b);
    }
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_bool(quark::detail::to_double(a) >= quark::detail::to_double(b));
    }
    return qv_bool(a.data.int_val >= b.data.int_val);
}

// Equality (type-sensitive)
inline QValue q_eq(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_eq(a, b);
    }
    if (a.type != b.type) {
        // Allow int/float comparison
        if ((a.type == QValue::VAL_INT || a.type == QValue::VAL_FLOAT) &&
            (b.type == QValue::VAL_INT || b.type == QValue::VAL_FLOAT)) {
            return qv_bool(quark::detail::to_double(a) == quark::detail::to_double(b));
        }
        return qv_bool(false);
    }

    switch (a.type) {
        case QValue::VAL_INT:
            return qv_bool(a.data.int_val == b.data.int_val);
        case QValue::VAL_FLOAT:
            return qv_bool(a.data.float_val == b.data.float_val);
        case QValue::VAL_BOOL:
            return qv_bool(a.data.bool_val == b.data.bool_val);
        case QValue::VAL_STRING:
            return qv_bool(strcmp(a.data.string_val, b.data.string_val) == 0);
        case QValue::VAL_NULL:
            return qv_bool(true);
        default:
            return qv_bool(false);
    }
}

// Not equal
inline QValue q_neq(QValue a, QValue b) {
    if (a.type == QValue::VAL_VECTOR || b.type == QValue::VAL_VECTOR) {
        return q_vec_neq(a, b);
    }
    return qv_bool(!q_eq(a, b).data.bool_val);
}

// ============================================================
// ops/logical.hpp
// ============================================================

// quark/ops/logical.hpp - Logical operations
// Logical AND
inline QValue q_and(QValue a, QValue b) {
    return qv_bool(q_truthy(a) && q_truthy(b));
}

// Logical OR
inline QValue q_or(QValue a, QValue b) {
    return qv_bool(q_truthy(a) || q_truthy(b));
}

// Logical NOT
inline QValue q_not(QValue a) {
    return qv_bool(!q_truthy(a));
}

// ============================================================
// builtins/io.hpp
// ============================================================

// quark/builtins/io.hpp - I/O operations
#include <cstdio>
#include <cstring>

// Print a QValue (without newline)
inline void print_qvalue(QValue v) {
    switch (v.type) {
        case QValue::VAL_INT:
            printf("%lld", v.data.int_val);
            break;
        case QValue::VAL_FLOAT:
            printf("%g", v.data.float_val);
            break;
        case QValue::VAL_STRING:
            printf("%s", v.data.string_val ? v.data.string_val : "null");
            break;
        case QValue::VAL_BOOL:
            printf(v.data.bool_val ? "true" : "false");
            break;
        case QValue::VAL_NULL:
            printf("null");
            break;
        case QValue::VAL_LIST:
            printf("[list len=%zu]", v.data.list_val ? v.data.list_val->size() : 0);
            break;
        case QValue::VAL_VECTOR:
            printf("[vector len=%d]", q_vec_size(v));
            break;
        case QValue::VAL_DICT:
            printf("[dict len=%zu]", v.data.dict_val ? v.data.dict_val->entries.size() : 0);
            break;
        case QValue::VAL_FUNC:
            printf("<function>");
            break;
        default:
            printf("<value>");
            break;
    }
}

// Print without newline
inline QValue q_print(QValue v) {
    print_qvalue(v);
    return qv_null();
}

// Print with newline
inline QValue q_println(QValue v) {
    print_qvalue(v);
    printf("\n");
    return qv_null();
}

// Read line from stdin (with optional prompt)
inline QValue q_input(QValue prompt) {
    // Print prompt if it's a string
    if (prompt.type == QValue::VAL_STRING && prompt.data.string_val) {
        printf("%s", prompt.data.string_val);
        fflush(stdout);
    }
    char buffer[4096];
    if (fgets(buffer, sizeof(buffer), stdin) != nullptr) {
        // Remove trailing newline
        size_t len = strlen(buffer);
        if (len > 0 && buffer[len - 1] == '\n') {
            buffer[len - 1] = '\0';
        }
        return qv_string(buffer);
    }
    return qv_string("");
}

// Read line from stdin (no prompt)
inline QValue q_input() {
    return q_input(qv_null());
}

// ============================================================
// builtins/conversion.hpp
// ============================================================

// quark/builtins/conversion.hpp - Type conversion operations
#include <cstdio>
#include <cstdlib>
#include <cstring>

// Get length of string or list
inline QValue q_len(QValue v) {
    switch (v.type) {
        case QValue::VAL_STRING:
            return qv_int(v.data.string_val ? static_cast<long long>(strlen(v.data.string_val)) : 0);
        case QValue::VAL_LIST:
            return qv_int(v.data.list_val ? static_cast<long long>(v.data.list_val->size()) : 0);
        case QValue::VAL_VECTOR:
            return qv_int(static_cast<long long>(q_vec_size(v)));
        case QValue::VAL_DICT:
            return qv_int(v.data.dict_val ? static_cast<long long>(v.data.dict_val->entries.size()) : 0);
        default:
            return qv_int(0);
    }
}

// Generic iterable index access used by for-loop lowering
inline QValue q_iter_get(QValue iterable, QValue index) {
    if (iterable.type == QValue::VAL_LIST || iterable.type == QValue::VAL_STRING) {
        return q_get(iterable, index);
    }
    if (iterable.type != QValue::VAL_VECTOR) {
        return qv_null();
    }
    if (!q_vec_has_valid_handle(iterable) || !q_vec_validate(*iterable.data.vector_val)) {
        return qv_null();
    }
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }

    long long idx = index.data.int_val;
    long long len = static_cast<long long>(iterable.data.vector_val->count);
    if (idx < 0) idx = len + idx;
    if (idx < 0 || idx >= len) {
        return qv_null();
    }

    size_t pos = static_cast<size_t>(idx);
    const QVector& vec = *iterable.data.vector_val;
    if (q_vec_is_null_at(vec, pos)) {
        return qv_null();
    }

    switch (vec.type) {
        case QVector::Type::F64: {
            const auto& values = std::get<std::vector<double>>(vec.storage);
            return qv_float(values[pos]);
        }
        case QVector::Type::I64: {
            const auto& values = std::get<std::vector<int64_t>>(vec.storage);
            return qv_int(static_cast<long long>(values[pos]));
        }
        case QVector::Type::BOOL: {
            const auto& values = std::get<std::vector<uint8_t>>(vec.storage);
            return qv_bool(values[pos] != 0);
        }
        case QVector::Type::STR: {
            const auto& values = std::get<QStringStorage>(vec.storage);
            uint32_t start = values.offsets[pos];
            uint32_t end = values.offsets[pos + 1];
            std::string s(values.bytes.data() + start, values.bytes.data() + end);
            return qv_string(s.c_str());
        }
        default:
            return qv_null();
    }
}

// Convert value to string
inline QValue q_str(QValue v) {
    char buffer[256];
    switch (v.type) {
        case QValue::VAL_INT:
            snprintf(buffer, sizeof(buffer), "%lld", v.data.int_val);
            return qv_string(buffer);
        case QValue::VAL_FLOAT:
            snprintf(buffer, sizeof(buffer), "%g", v.data.float_val);
            return qv_string(buffer);
        case QValue::VAL_BOOL:
            return qv_string(v.data.bool_val ? "true" : "false");
        case QValue::VAL_STRING:
            return v.data.string_val ? v : qv_string("");
        case QValue::VAL_NULL:
            return qv_string("null");
        case QValue::VAL_LIST:
            snprintf(buffer, sizeof(buffer), "[list len=%zu]",
                     v.data.list_val ? v.data.list_val->size() : 0);
            return qv_string(buffer);
        case QValue::VAL_VECTOR:
            snprintf(buffer, sizeof(buffer), "[vector len=%d]", q_vec_size(v));
            return qv_string(buffer);
        case QValue::VAL_DICT:
            snprintf(buffer, sizeof(buffer), "[dict len=%zu]",
                     v.data.dict_val ? v.data.dict_val->entries.size() : 0);
            return qv_string(buffer);
        case QValue::VAL_FUNC:
            return qv_string("<function>");
        default:
            return qv_string("<value>");
    }
}

// Convert value to integer
inline QValue q_int(QValue v) {
    switch (v.type) {
        case QValue::VAL_INT:
            return v;
        case QValue::VAL_FLOAT:
            return qv_int(static_cast<long long>(v.data.float_val));
        case QValue::VAL_BOOL:
            return qv_int(v.data.bool_val ? 1 : 0);
        case QValue::VAL_STRING:
            return qv_int(v.data.string_val ? atoll(v.data.string_val) : 0);
        default:
            return qv_int(0);
    }
}

// Convert value to float
inline QValue q_float(QValue v) {
    switch (v.type) {
        case QValue::VAL_INT:
            return qv_float(static_cast<double>(v.data.int_val));
        case QValue::VAL_FLOAT:
            return v;
        case QValue::VAL_BOOL:
            return qv_float(v.data.bool_val ? 1.0 : 0.0);
        case QValue::VAL_STRING:
            return qv_float(v.data.string_val ? atof(v.data.string_val) : 0.0);
        default:
            return qv_float(0.0);
    }
}

// Convert value to boolean
inline QValue q_bool(QValue v) {
    return qv_bool(q_truthy(v));
}

// Return runtime type name as string
inline QValue q_type(QValue v) {
    switch (v.type) {
        case QValue::VAL_INT:
            return qv_string("int");
        case QValue::VAL_FLOAT:
            return qv_string("float");
        case QValue::VAL_STRING:
            return qv_string("str");
        case QValue::VAL_BOOL:
            return qv_string("bool");
        case QValue::VAL_NULL:
            return qv_string("null");
        case QValue::VAL_LIST:
            return qv_string("list");
        case QValue::VAL_DICT:
            return qv_string("dict");
        case QValue::VAL_FUNC:
            return qv_string("func");
        case QValue::VAL_RESULT:
            return qv_string("result");
        case QValue::VAL_VECTOR: {
            if (!q_vec_has_valid_handle(v) || !q_vec_validate(*v.data.vector_val)) {
                return qv_string("vector[invalid]");
            }
            char buffer[64];
            std::snprintf(buffer, sizeof(buffer), "vector[%s]", q_vec_dtype_name(*v.data.vector_val));
            return qv_string(buffer);
        }
        default:
            return qv_string("unknown");
    }
}

// ============================================================
// builtins/math.hpp
// ============================================================

// quark/builtins/math.hpp - Math operations
#include <cmath>
#include <cstdlib>

// Helper functions to_double() and either_float() are defined in arithmetic.hpp
// (removed from here to avoid duplication in the concatenated runtime.hpp)

// Absolute value
inline QValue q_abs(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    if (v.type == QValue::VAL_FLOAT) {
        return qv_float(fabs(v.data.float_val));
    }
    return qv_int(llabs(v.data.int_val));
}

// Minimum of two values
inline QValue q_min(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        double av = quark::detail::to_double(a);
        double bv = quark::detail::to_double(b);
        return qv_float(av < bv ? av : bv);
    }
    return qv_int(a.data.int_val < b.data.int_val ? a.data.int_val : b.data.int_val);
}

// Minimum of vector values
inline QValue q_min(QValue v) {
    if (v.type == QValue::VAL_VECTOR) {
        return q_vec_min(v);
    }
    return qv_null();
}

// Maximum of two values
inline QValue q_max(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        double av = quark::detail::to_double(a);
        double bv = quark::detail::to_double(b);
        return qv_float(av > bv ? av : bv);
    }
    return qv_int(a.data.int_val > b.data.int_val ? a.data.int_val : b.data.int_val);
}

// Maximum of vector values
inline QValue q_max(QValue v) {
    if (v.type == QValue::VAL_VECTOR) {
        return q_vec_max(v);
    }
    return qv_null();
}

// Sum of vector values
inline QValue q_sum(QValue v) {
    if (v.type == QValue::VAL_VECTOR) {
        return q_vec_sum(v);
    }
    return qv_null();
}

// Square root (always returns float)
inline QValue q_sqrt(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    double val = quark::detail::to_double(v);
    // Check for negative values
    if (val < 0.0) {
        return qv_null();
    }
    return qv_float(sqrt(val));
}

// Floor (returns int)
inline QValue q_floor(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    if (v.type == QValue::VAL_INT) return v;
    return qv_int(static_cast<long long>(floor(v.data.float_val)));
}

// Ceiling (returns int)
inline QValue q_ceil(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    if (v.type == QValue::VAL_INT) return v;
    return qv_int(static_cast<long long>(ceil(v.data.float_val)));
}

// Round to nearest integer (returns int)
inline QValue q_round(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    if (v.type == QValue::VAL_INT) return v;
    return qv_int(static_cast<long long>(round(v.data.float_val)));
}

// ============================================================
// ops/member.hpp
// ============================================================

// quark/ops/member.hpp - Dict member access
#include <cstring>
#include <cstdio>

// Dict member read: d.key  q_member_get(d, "key")
inline QValue q_member_get(QValue obj, const char* member) {
    if (obj.type == QValue::VAL_NULL) {
        fprintf(stderr, "runtime error: cannot access member '%s' on null\n", member);
        return qv_null();
    }

    if (obj.type == QValue::VAL_DICT) {
        return q_dict_get(obj, qv_string(member));
    }

    const char* type_names[] = {"int", "float", "string", "bool", "null", "list", "vector", "dict", "func", "result"};
    const char* type_name = (obj.type >= 0 && obj.type <= 9) ? type_names[obj.type] : "unknown";
    fprintf(stderr, "runtime error: dot access is only supported on dict; got type '%s'\n", type_name);
    return qv_null();
}

// Dict member write: d.key = value  q_member_set(d, "key", value)
inline QValue q_member_set(QValue obj, const char* member, QValue value) {
    if (obj.type == QValue::VAL_DICT) {
        return q_dict_set(obj, qv_string(member), value);
    }
    fprintf(stderr, "runtime error: cannot set member '%s' on non-dict type\n", member);
    return qv_null();
}

#endif // QUARK_RUNTIME_HPP
