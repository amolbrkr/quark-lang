"""
Python Code Generator for Quark Language

Generates Python source code (.py files) from Quark AST.
"""

from .helper_types import NodeType, TreeNode
from typing import List


class QuarkCodeGen:
    """Generates Python code from Quark AST"""

    def __init__(self):
        self.indent_level = 0
        self.output: List[str] = []

    def indent(self):
        """Increase indentation level"""
        self.indent_level += 1

    def dedent(self):
        """Decrease indentation level"""
        self.indent_level = max(0, self.indent_level - 1)

    def emit(self, code: str, newline: bool = True):
        """Emit a line of code with current indentation"""
        if code.strip():  # Only indent non-empty lines
            indented = ("    " * self.indent_level) + code
        else:
            indented = code

        if newline:
            self.output.append(indented)
        else:
            # Append to last line
            if self.output:
                self.output[-1] += code
            else:
                self.output.append(code)

    def generate(self, ast: TreeNode) -> str:
        """Generate Python code from AST"""
        self.output = []
        self.indent_level = 0

        # Add header comment
        self.emit("# Generated by Quark compiler")
        self.emit("")

        # Visit AST
        self.visit(ast)

        return "\n".join(self.output)

    def visit(self, node: TreeNode) -> str:
        """Visit a node and generate code"""
        if node is None:
            return ""

        method_name = f'visit_{node.type.name}'
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node: TreeNode) -> str:
        """Default visitor"""
        results = []
        for child in node.children:
            result = self.visit(child)
            if result:
                results.append(result)
        return " ".join(results) if results else ""

    # ==================== Statement Visitors ====================

    def visit_CompilationUnit(self, node: TreeNode) -> str:
        """Visit top-level compilation unit"""
        for child in node.children:
            result = self.visit(child)
            # If a top-level expression returns a string (like FunctionCall), emit it
            if result and child.type in [NodeType.FunctionCall]:
                self.emit(result)
        return ""

    def visit_Block(self, node: TreeNode) -> str:
        """Visit a block of statements"""
        for child in node.children:
            self.visit(child)
        return ""

    def visit_Function(self, node: TreeNode) -> str:
        """Generate Python function definition"""
        # Structure: [name_node, params_node, body_node]
        name_node = node.children[0]
        params_node = node.children[1]
        body_node = node.children[2]

        func_name = name_node.tok.value

        # Generate parameter list
        params = []
        for param in params_node.children:
            params.append(param.tok.value)

        param_str = ", ".join(params)

        # Emit function definition
        self.emit(f"def {func_name}({param_str}):")
        self.indent()

        # Generate body
        if not body_node.children:
            self.emit("pass")
        elif len(body_node.children) == 1 and body_node.children[0].type == NodeType.Ternary:
            # Single expression (ternary) - implicit return
            expr_code = self.visit(body_node.children[0])
            self.emit(f"return {expr_code}")
        else:
            self.visit(body_node)

        self.dedent()
        self.emit("")  # Empty line after function

        return ""

    def visit_IfStatement(self, node: TreeNode) -> str:
        """Generate Python if statement"""
        # Structure: [condition, then_block, elseif_blocks..., else_block]
        condition = node.children[0]
        then_block = node.children[1]

        # Generate if
        condition_code = self.visit(condition)
        self.emit(f"if {condition_code}:")
        self.indent()
        self.visit(then_block)
        self.dedent()

        # Handle elseif and else
        for i, child in enumerate(node.children[2:], start=2):
            if child.type == NodeType.IfStatement:
                # This is an elseif - recursively handled
                elseif_condition = child.children[0]
                elseif_block = child.children[1]

                condition_code = self.visit(elseif_condition)
                self.emit(f"elif {condition_code}:")
                self.indent()
                self.visit(elseif_block)
                self.dedent()
            else:
                # This is else block
                self.emit("else:")
                self.indent()
                self.visit(child)
                self.dedent()

        return ""

    def visit_WhenStatement(self, node: TreeNode) -> str:
        """Generate Python pattern matching using if-elif-else"""
        # Structure: [match_expr, pattern1, pattern2, ...]
        match_expr = node.children[0]
        patterns = node.children[1:]

        match_var = self.visit(match_expr)

        # Generate if-elif chain for patterns
        for i, pattern in enumerate(patterns):
            self.visit_Pattern_inline(pattern, match_var, is_first=(i == 0))

        return ""

    def visit_Pattern_inline(self, node: TreeNode, match_var: str, is_first: bool = False):
        """Generate pattern matching as if-elif"""
        # Structure: [pattern_expr(s)..., result_expr]
        result_expr = node.children[-1]
        pattern_exprs = node.children[:-1]

        # Generate condition
        conditions = []
        for pattern_expr in pattern_exprs:
            if pattern_expr.type == NodeType.Identifier and pattern_expr.tok.value == '_':
                # Wildcard - always true
                conditions.append("True")
            else:
                pattern_code = self.visit(pattern_expr)
                conditions.append(f"({match_var} == {pattern_code})")

        condition = " or ".join(conditions)

        # Emit if/elif
        if is_first:
            self.emit(f"if {condition}:")
        else:
            self.emit(f"elif {condition}:")

        self.indent()

        # Generate result
        result_code = self.visit(result_expr)
        self.emit(f"return {result_code}")

        self.dedent()

    def visit_Pattern(self, node: TreeNode) -> str:
        """Visit pattern (handled by visit_Pattern_inline in context)"""
        # This shouldn't be called directly
        return ""

    def visit_ForLoop(self, node: TreeNode) -> str:
        """Generate Python for loop"""
        # Structure: [loop_var, iterable, body]
        loop_var = node.children[0]
        iterable = node.children[1]
        body = node.children[2]

        var_name = loop_var.tok.value
        iterable_code = self.visit(iterable)

        self.emit(f"for {var_name} in {iterable_code}:")
        self.indent()

        if not body.children:
            self.emit("pass")
        else:
            self.visit(body)

        self.dedent()
        return ""

    def visit_WhileLoop(self, node: TreeNode) -> str:
        """Generate Python while loop"""
        # Structure: [condition, body]
        condition = node.children[0]
        body = node.children[1]

        condition_code = self.visit(condition)

        self.emit(f"while {condition_code}:")
        self.indent()

        if not body.children:
            self.emit("pass")
        else:
            self.visit(body)

        self.dedent()
        return ""

    # ==================== Expression Visitors ====================

    def visit_Expression(self, node: TreeNode) -> str:
        """Visit expression statement"""
        if node.children:
            child = node.children[0]
            result = self.visit(child)
            if result and child.type == NodeType.FunctionCall:
                # Function calls at statement level should be emitted
                self.emit(result)
            elif result:
                self.emit(result)
        return ""

    def visit_Statement(self, node: TreeNode) -> str:
        """Visit generic statement"""
        if node.children:
            result = self.visit(node.children[0])
            if result:
                self.emit(result)
        return ""

    def visit_Operator(self, node: TreeNode) -> str:
        """Generate operator expression"""
        op = node.tok.value

        if len(node.children) == 1:
            # Unary operator
            operand = self.visit(node.children[0])

            # Map operators
            op_map = {
                '!': 'not ',
                '~': '~',
                '-': '-'
            }
            python_op = op_map.get(op, op)
            return f"{python_op}{operand}"

        elif len(node.children) == 2:
            left = self.visit(node.children[0])
            right = self.visit(node.children[1])

            # Map operators to Python equivalents
            op_map = {
                '==': '==',
                '!=': '!=',
                '<': '<',
                '<=': '<=',
                '>': '>',
                '>=': '>=',
                '+': '+',
                '-': '-',
                '*': '*',
                '/': '/',
                '%': '%',
                '**': '**',
                'and': 'and',
                'or': 'or',
                '&': '&',
                '..': '...',  # Will be handled specially
                '.': '.',
                ',': ',',
                '=': '='
            }

            python_op = op_map.get(op, op)

            # Special handling for assignment
            if op == '=':
                # This is a statement, not an expression
                self.emit(f"{left} = {right}")
                return ""

            # Special handling for range
            if op == '..':
                return f"range({left}, {right})"

            # Special handling for member access
            if op == '.':
                return f"{left}.{right}"

            return f"({left} {python_op} {right})"

        return ""

    def visit_Identifier(self, node: TreeNode) -> str:
        """Generate identifier"""
        return node.tok.value

    def visit_Literal(self, node: TreeNode) -> str:
        """Generate literal"""
        tok_type = node.tok.type
        value = node.tok.value

        if tok_type == 'INT':
            return str(value)
        elif tok_type == 'FLOAT':
            return str(value)
        elif tok_type == 'STR':
            # Escape and quote string
            escaped = str(value).replace('\\', '\\\\').replace("'", "\\'")
            return f"'{escaped}'"
        elif tok_type == 'LBRACE':
            # List literal
            elements = []
            for child in node.children:
                elements.append(self.visit(child))
            return "[" + ", ".join(elements) + "]"
        elif tok_type == 'BLOCKSTART':
            # Dict literal
            pairs = []
            for child in node.children:
                # Each child is an operator node with key:value
                key = self.visit(child.children[0])
                value = self.visit(child.children[1])
                pairs.append(f"{key}: {value}")
            return "{" + ", ".join(pairs) + "}"

        return str(value)

    def visit_FunctionCall(self, node: TreeNode) -> str:
        """Generate function call"""
        # Structure: [func_identifier, arguments_node]
        func_node = node.children[0]
        args_node = node.children[1]

        func_name = self.visit(func_node)
        args = self.visit(args_node)

        return f"{func_name}({args})"

    def visit_Arguments(self, node: TreeNode) -> str:
        """Generate argument list"""
        args = []
        for arg in node.children:
            arg_code = self.visit(arg)
            if arg_code:
                args.append(arg_code)
        return ", ".join(args)

    def visit_Ternary(self, node: TreeNode) -> str:
        """Generate Python ternary expression"""
        # Structure: [condition, value_if_true, value_if_false]
        # Quark: value if condition else other
        # Python: value if condition else other
        condition = self.visit(node.children[0])
        value_if_true = self.visit(node.children[1])
        value_if_false = self.visit(node.children[2])

        return f"({value_if_true} if {condition} else {value_if_false})"

    def visit_Pipe(self, node: TreeNode) -> str:
        """Generate pipe operation (for now, skip - will implement later)"""
        # Structure: [left_expr, right_expr]
        # For now, just handle as nested function calls
        left = self.visit(node.children[0])
        right = self.visit(node.children[1])

        # If right is a function call, inject left as first argument
        # For now, simple placeholder
        return f"pipe({left}, {right})"
