// runtime.hpp - Quark Runtime Library (Auto-generated)
// DO NOT EDIT - Generated by build_runtime.ps1
// Regenerate with: cd runtime && pwsh build_runtime.ps1

#ifndef QUARK_RUNTIME_HPP
#define QUARK_RUNTIME_HPP

// Standard library includes
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cctype>
#include <cstdarg>

// ============================================================
// core/gc.hpp
// ============================================================

// quark/core/gc.hpp - Boehm GC integration wrapper
// Boehm GC configuration
// Define QUARK_USE_GC to enable garbage collection
// Otherwise falls back to manual memory management (leaking for now)

#ifdef QUARK_USE_GC
    #include <gc.h>

    // Initialize GC (call once at program start)
    inline void q_gc_init() {
        GC_INIT();
    }

    // GC allocation macros (expand to Boehm GC calls)
    #define q_malloc(n)         GC_MALLOC(n)
    #define q_malloc_atomic(n)  GC_MALLOC_ATOMIC(n)
    #define q_realloc(p, n)     GC_REALLOC(p, n)
    #define q_free(p)           /* GC handles it */
    #define q_strdup(s)         GC_STRDUP(s)

    // For future tensor/array data (no pointer scanning needed)
    #define q_malloc_tensor(n)  GC_MALLOC_ATOMIC(n)

#else
    // No GC - use standard malloc (will leak for now)
    #include <cstdlib>
    #include <cstring>

    inline void q_gc_init() {
        // No-op when GC disabled
    }

    #define q_malloc(n)         malloc(n)
    #define q_malloc_atomic(n)  malloc(n)
    #define q_realloc(p, n)     realloc(p, n)
    #define q_free(p)           free(p)

    inline char* q_strdup(const char* s) {
        return strdup(s);
    }

    #define q_malloc_tensor(n)  malloc(n)
#endif

// ============================================================
// core/value.hpp
// ============================================================

// quark/core/value.hpp - QValue tagged union type
#include <cstdlib>
#include <vector>

// Forward declaration
struct QValue;

// Type alias for list storage
using QList = std::vector<QValue>;

// QValue: Tagged union for all Quark runtime values
struct QValue {
    enum ValueType {
        VAL_INT,
        VAL_FLOAT,
        VAL_STRING,
        VAL_BOOL,
        VAL_NULL,
        VAL_LIST,
        VAL_FUNC
    } type;

    union {
        long long int_val;
        double float_val;
        char* string_val;
        bool bool_val;
        QList* list_val;    // std::vector<QValue>* - automatic memory management
        void* func_val;
    } data;
};

// Function pointer types for dynamic calls (different arities)
using QFunc0 = QValue (*)();
using QFunc1 = QValue (*)(QValue);
using QFunc2 = QValue (*)(QValue, QValue);
using QFunc3 = QValue (*)(QValue, QValue, QValue);
using QFunc4 = QValue (*)(QValue, QValue, QValue, QValue);

// ============================================================
// core/constructors.hpp
// ============================================================

// quark/core/constructors.hpp - QValue constructors
#include <cstring>
#include <cstdarg>

// Integer value constructor
inline QValue qv_int(long long v) {
    QValue q;
    q.type = QValue::VAL_INT;
    q.data.int_val = v;
    return q;
}

// Float value constructor
inline QValue qv_float(double v) {
    QValue q;
    q.type = QValue::VAL_FLOAT;
    q.data.float_val = v;
    return q;
}

// String value constructor (makes a copy using GC)
inline QValue qv_string(const char* v) {
    QValue q;
    q.type = QValue::VAL_STRING;
    q.data.string_val = q_strdup(v);
    return q;
}

// Boolean value constructor
inline QValue qv_bool(bool v) {
    QValue q;
    q.type = QValue::VAL_BOOL;
    q.data.bool_val = v;
    return q;
}

// Null value constructor
inline QValue qv_null() {
    QValue q;
    q.type = QValue::VAL_NULL;
    return q;
}

// Function value constructor
inline QValue qv_func(void* f) {
    QValue q;
    q.type = QValue::VAL_FUNC;
    q.data.func_val = f;
    return q;
}

// List value constructor with optional initial capacity
// Note: std::vector internally uses new/delete, which Boehm GC intercepts
inline QValue qv_list(int initial_cap = 0) {
    QValue q;
    q.type = QValue::VAL_LIST;
    q.data.list_val = new QList();  // Boehm GC intercepts operator new
    if (initial_cap > 0) {
        q.data.list_val->reserve(initial_cap);
    }
    return q;
}

// List value constructor from variadic arguments
inline QValue qv_list_from(int count, ...) {
    QValue q;
    q.type = QValue::VAL_LIST;
    q.data.list_val = new QList();  // Boehm GC intercepts operator new
    q.data.list_val->reserve(count);
    va_list args;
    va_start(args, count);
    for (int i = 0; i < count; i++) {
        q.data.list_val->push_back(va_arg(args, QValue));
    }
    va_end(args);
    return q;
}

// List value constructor from initializer list (C++ style)
inline QValue qv_list_init(std::initializer_list<QValue> items) {
    QValue q;
    q.type = QValue::VAL_LIST;
    q.data.list_val = new QList(items);  // Boehm GC intercepts operator new
    return q;
}

// ============================================================
// core/truthy.hpp
// ============================================================

// quark/core/truthy.hpp - Truthiness checking
#include <cstring>

// Check if a value is truthy (used for conditions)
inline bool q_truthy(QValue v) {
    switch (v.type) {
        case QValue::VAL_BOOL:
            return v.data.bool_val;
        case QValue::VAL_INT:
            return v.data.int_val != 0;
        case QValue::VAL_FLOAT:
            return v.data.float_val != 0.0;
        case QValue::VAL_STRING:
            return v.data.string_val != nullptr && strlen(v.data.string_val) > 0;
        case QValue::VAL_NULL:
            return false;
        case QValue::VAL_LIST:
            return v.data.list_val && !v.data.list_val->empty();
        case QValue::VAL_FUNC:
            return v.data.func_val != nullptr;
        default:
            return true;
    }
}

// ============================================================
// ops/arithmetic.hpp
// ============================================================

// quark/ops/arithmetic.hpp - Arithmetic operations
#include <cmath>

namespace quark {
namespace detail {

// Helper to extract numeric value as double
#ifndef QUARK_DETAIL_TO_DOUBLE_DEFINED
#define QUARK_DETAIL_TO_DOUBLE_DEFINED
inline double to_double(const QValue& v) {
    return v.type == QValue::VAL_FLOAT ? v.data.float_val
                                       : static_cast<double>(v.data.int_val);
}

inline bool either_float(const QValue& a, const QValue& b) {
    return a.type == QValue::VAL_FLOAT || b.type == QValue::VAL_FLOAT;
}
#endif

} // namespace detail
} // namespace quark

// Addition: int + int = int, otherwise float
inline QValue q_add(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_float(quark::detail::to_double(a) + quark::detail::to_double(b));
    }
    return qv_int(a.data.int_val + b.data.int_val);
}

// Subtraction: int - int = int, otherwise float
inline QValue q_sub(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_float(quark::detail::to_double(a) - quark::detail::to_double(b));
    }
    return qv_int(a.data.int_val - b.data.int_val);
}

// Multiplication: int * int = int, otherwise float
inline QValue q_mul(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_float(quark::detail::to_double(a) * quark::detail::to_double(b));
    }
    return qv_int(a.data.int_val * b.data.int_val);
}

// Division: always returns float for precision
inline QValue q_div(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    double bv = quark::detail::to_double(b);
    // Check for division by zero
    if (bv == 0.0) {
        return qv_null();
    }
    return qv_float(quark::detail::to_double(a) / bv);
}

// Modulo: integer only
inline QValue q_mod(QValue a, QValue b) {
    // Type guard: only INT is valid for modulo
    if (a.type != QValue::VAL_INT || b.type != QValue::VAL_INT) {
        return qv_null();
    }
    // Check for modulo by zero
    if (b.data.int_val == 0) {
        return qv_null();
    }
    return qv_int(a.data.int_val % b.data.int_val);
}

// Power: preserves int type when possible
inline QValue q_pow(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    double av = quark::detail::to_double(a);
    double bv = quark::detail::to_double(b);
    double result = std::pow(av, bv);

    if (quark::detail::either_float(a, b)) {
        return qv_float(result);
    }
    return qv_int(static_cast<long long>(result));
}

// Unary negation
inline QValue q_neg(QValue a) {
    // Type guard: only INT and FLOAT are valid
    if (a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    if (a.type == QValue::VAL_FLOAT) {
        return qv_float(-a.data.float_val);
    }
    return qv_int(-a.data.int_val);
}

// ============================================================
// ops/comparison.hpp
// ============================================================

// quark/ops/comparison.hpp - Comparison operations
#include <cstring>

// Helper functions to_double() and either_float() are defined in arithmetic.hpp
// (removed from here to avoid duplication in the concatenated runtime.hpp)

// Less than
inline QValue q_lt(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_bool(quark::detail::to_double(a) < quark::detail::to_double(b));
    }
    return qv_bool(a.data.int_val < b.data.int_val);
}

// Less than or equal
inline QValue q_lte(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_bool(quark::detail::to_double(a) <= quark::detail::to_double(b));
    }
    return qv_bool(a.data.int_val <= b.data.int_val);
}

// Greater than
inline QValue q_gt(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_bool(quark::detail::to_double(a) > quark::detail::to_double(b));
    }
    return qv_bool(a.data.int_val > b.data.int_val);
}

// Greater than or equal
inline QValue q_gte(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        return qv_bool(quark::detail::to_double(a) >= quark::detail::to_double(b));
    }
    return qv_bool(a.data.int_val >= b.data.int_val);
}

// Equality (type-sensitive)
inline QValue q_eq(QValue a, QValue b) {
    if (a.type != b.type) {
        // Allow int/float comparison
        if ((a.type == QValue::VAL_INT || a.type == QValue::VAL_FLOAT) &&
            (b.type == QValue::VAL_INT || b.type == QValue::VAL_FLOAT)) {
            return qv_bool(quark::detail::to_double(a) == quark::detail::to_double(b));
        }
        return qv_bool(false);
    }

    switch (a.type) {
        case QValue::VAL_INT:
            return qv_bool(a.data.int_val == b.data.int_val);
        case QValue::VAL_FLOAT:
            return qv_bool(a.data.float_val == b.data.float_val);
        case QValue::VAL_BOOL:
            return qv_bool(a.data.bool_val == b.data.bool_val);
        case QValue::VAL_STRING:
            return qv_bool(strcmp(a.data.string_val, b.data.string_val) == 0);
        case QValue::VAL_NULL:
            return qv_bool(true);
        default:
            return qv_bool(false);
    }
}

// Not equal
inline QValue q_neq(QValue a, QValue b) {
    return qv_bool(!q_eq(a, b).data.bool_val);
}

// ============================================================
// ops/logical.hpp
// ============================================================

// quark/ops/logical.hpp - Logical operations
// Logical AND
inline QValue q_and(QValue a, QValue b) {
    return qv_bool(q_truthy(a) && q_truthy(b));
}

// Logical OR
inline QValue q_or(QValue a, QValue b) {
    return qv_bool(q_truthy(a) || q_truthy(b));
}

// Logical NOT
inline QValue q_not(QValue a) {
    return qv_bool(!q_truthy(a));
}

// ============================================================
// types/list.hpp
// ============================================================

// quark/types/list.hpp - List operations using std::vector
// Push item to end of list
inline QValue q_push(QValue list, QValue item) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    list.data.list_val->push_back(item);
    return list;
}

// Pop item from end of list
inline QValue q_pop(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val || list.data.list_val->empty()) {
        return qv_null();
    }
    QValue item = list.data.list_val->back();
    list.data.list_val->pop_back();
    return item;
}

// Get item at index (supports negative indexing)
inline QValue q_get(QValue list, QValue index) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    // Type guard: index must be INT
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }
    int idx = static_cast<int>(index.data.int_val);
    int len = static_cast<int>(list.data.list_val->size());
    if (idx < 0) idx = len + idx;
    if (idx < 0 || idx >= len) {
        return qv_null();
    }
    return (*list.data.list_val)[idx];
}

// Set item at index (supports negative indexing)
inline QValue q_set(QValue list, QValue index, QValue value) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    // Type guard: index must be INT
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }
    int idx = static_cast<int>(index.data.int_val);
    int len = static_cast<int>(list.data.list_val->size());
    if (idx < 0) idx = len + idx;
    if (idx < 0 || idx >= len) {
        return qv_null();
    }
    (*list.data.list_val)[idx] = value;
    return value;
}

// Get list size
inline int q_list_size(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return 0;
    }
    return static_cast<int>(list.data.list_val->size());
}

// Check if list is empty
inline bool q_list_empty(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return true;
    }
    return list.data.list_val->empty();
}

// Clear all items from list
inline QValue q_list_clear(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    list.data.list_val->clear();
    return list;
}

// Insert item at index
inline QValue q_insert(QValue list, QValue index, QValue item) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    // Type guard: index must be INT
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }
    int idx = static_cast<int>(index.data.int_val);
    int len = static_cast<int>(list.data.list_val->size());
    if (idx < 0) idx = len + idx;
    if (idx < 0) idx = 0;
    if (idx > len) idx = len;
    list.data.list_val->insert(list.data.list_val->begin() + idx, item);
    return list;
}

// Remove item at index
inline QValue q_remove(QValue list, QValue index) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    // Type guard: index must be INT
    if (index.type != QValue::VAL_INT) {
        return qv_null();
    }
    int idx = static_cast<int>(index.data.int_val);
    int len = static_cast<int>(list.data.list_val->size());
    if (idx < 0) idx = len + idx;
    if (idx < 0 || idx >= len) {
        return qv_null();
    }
    QValue item = (*list.data.list_val)[idx];
    list.data.list_val->erase(list.data.list_val->begin() + idx);
    return item;
}

// Concatenate two lists, returns new list
inline QValue q_list_concat(QValue a, QValue b) {
    if (a.type != QValue::VAL_LIST || b.type != QValue::VAL_LIST) {
        return qv_null();
    }
    QValue result = qv_list();
    if (a.data.list_val) {
        for (const auto& item : *a.data.list_val) {
            result.data.list_val->push_back(item);
        }
    }
    if (b.data.list_val) {
        for (const auto& item : *b.data.list_val) {
            result.data.list_val->push_back(item);
        }
    }
    return result;
}

// Slice list [start:end), returns new list
inline QValue q_slice(QValue list, QValue start, QValue end) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    // Type guard: start and end must be INT
    if (start.type != QValue::VAL_INT || end.type != QValue::VAL_INT) {
        return qv_null();
    }
    int len = static_cast<int>(list.data.list_val->size());
    int s = static_cast<int>(start.data.int_val);
    int e = static_cast<int>(end.data.int_val);

    // Handle negative indices
    if (s < 0) s = len + s;
    if (e < 0) e = len + e;

    // Clamp to bounds
    if (s < 0) s = 0;
    if (e > len) e = len;
    if (s >= e) return qv_list();

    QValue result = qv_list(e - s);
    for (int i = s; i < e; i++) {
        result.data.list_val->push_back((*list.data.list_val)[i]);
    }
    return result;
}

// Reverse list in place
inline QValue q_reverse(QValue list) {
    if (list.type != QValue::VAL_LIST || !list.data.list_val) {
        return qv_null();
    }
    std::reverse(list.data.list_val->begin(), list.data.list_val->end());
    return list;
}

// Free list memory (for manual cleanup if needed)
inline void q_list_free(QValue list) {
    if (list.type == QValue::VAL_LIST && list.data.list_val) {
        delete list.data.list_val;
    }
}

// Range functions - generate lists of integers
// range(end) - generates [0, 1, 2, ..., end-1]
inline QValue q_range(QValue end) {
    long long e = 0;
    if (end.type == QValue::VAL_INT) {
        e = end.data.int_val;
    } else if (end.type == QValue::VAL_FLOAT) {
        e = static_cast<long long>(end.data.float_val);
    } else {
        return qv_list();
    }

    QValue result = qv_list();
    for (long long i = 0; i < e; i++) {
        result.data.list_val->push_back(qv_int(i));
    }
    return result;
}

// range(start, end) - generates [start, start+1, ..., end-1]
inline QValue q_range(QValue start, QValue end) {
    long long s = 0, e = 0;

    if (start.type == QValue::VAL_INT) {
        s = start.data.int_val;
    } else if (start.type == QValue::VAL_FLOAT) {
        s = static_cast<long long>(start.data.float_val);
    } else {
        return qv_list();
    }

    if (end.type == QValue::VAL_INT) {
        e = end.data.int_val;
    } else if (end.type == QValue::VAL_FLOAT) {
        e = static_cast<long long>(end.data.float_val);
    } else {
        return qv_list();
    }

    QValue result = qv_list();
    if (s < e) {
        for (long long i = s; i < e; i++) {
            result.data.list_val->push_back(qv_int(i));
        }
    } else {
        for (long long i = s; i > e; i--) {
            result.data.list_val->push_back(qv_int(i));
        }
    }
    return result;
}

// range(start, end, step) - generates [start, start+step, start+2*step, ...]
inline QValue q_range(QValue start, QValue end, QValue step) {
    long long s = 0, e = 0, st = 1;

    if (start.type == QValue::VAL_INT) {
        s = start.data.int_val;
    } else if (start.type == QValue::VAL_FLOAT) {
        s = static_cast<long long>(start.data.float_val);
    } else {
        return qv_list();
    }

    if (end.type == QValue::VAL_INT) {
        e = end.data.int_val;
    } else if (end.type == QValue::VAL_FLOAT) {
        e = static_cast<long long>(end.data.float_val);
    } else {
        return qv_list();
    }

    if (step.type == QValue::VAL_INT) {
        st = step.data.int_val;
    } else if (step.type == QValue::VAL_FLOAT) {
        st = static_cast<long long>(step.data.float_val);
    } else {
        return qv_list();
    }

    if (st == 0) {
        return qv_list(); // Avoid infinite loop
    }

    QValue result = qv_list();
    if (st > 0) {
        for (long long i = s; i < e; i += st) {
            result.data.list_val->push_back(qv_int(i));
        }
    } else {
        for (long long i = s; i > e; i += st) {
            result.data.list_val->push_back(qv_int(i));
        }
    }
    return result;
}

// ============================================================
// types/string.hpp
// ============================================================

// quark/types/string.hpp - String operations
#include <cstring>
#include <cctype>
#include <cstdlib>

// Convert string to uppercase
inline QValue q_upper(QValue v) {
    // Type guard: only STRING is valid
    if (v.type != QValue::VAL_STRING) return qv_null();
    char* result = q_strdup(v.data.string_val);
    for (int i = 0; result[i]; i++) {
        result[i] = static_cast<char>(toupper(static_cast<unsigned char>(result[i])));
    }
    QValue q = qv_string(result);
    // GC will handle cleanup - no explicit free needed
    return q;
}

// Convert string to lowercase
inline QValue q_lower(QValue v) {
    // Type guard: only STRING is valid
    if (v.type != QValue::VAL_STRING) return qv_null();
    char* result = q_strdup(v.data.string_val);
    for (int i = 0; result[i]; i++) {
        result[i] = static_cast<char>(tolower(static_cast<unsigned char>(result[i])));
    }
    QValue q = qv_string(result);
    // GC will handle cleanup - no explicit free needed
    return q;
}

// Trim whitespace from both ends
inline QValue q_trim(QValue v) {
    // Type guard: only STRING is valid
    if (v.type != QValue::VAL_STRING) return qv_null();
    const char* start = v.data.string_val;
    while (*start && isspace(static_cast<unsigned char>(*start))) start++;
    if (*start == '\0') return qv_string("");

    const char* end = v.data.string_val + strlen(v.data.string_val) - 1;
    while (end > start && isspace(static_cast<unsigned char>(*end))) end--;

    size_t len = static_cast<size_t>(end - start + 1);
    char* result = static_cast<char*>(q_malloc_atomic(len + 1));
    strncpy(result, start, len);
    result[len] = '\0';

    QValue q = qv_string(result);
    // GC will handle cleanup - no explicit free needed
    return q;
}

// Check if string contains substring
inline QValue q_contains(QValue str, QValue sub) {
    // Type guard: both must be STRING
    if (str.type != QValue::VAL_STRING || sub.type != QValue::VAL_STRING) {
        return qv_null();
    }
    return qv_bool(strstr(str.data.string_val, sub.data.string_val) != nullptr);
}

// Check if string starts with prefix
inline QValue q_startswith(QValue str, QValue prefix) {
    // Type guard: both must be STRING
    if (str.type != QValue::VAL_STRING || prefix.type != QValue::VAL_STRING) {
        return qv_null();
    }
    size_t plen = strlen(prefix.data.string_val);
    return qv_bool(strncmp(str.data.string_val, prefix.data.string_val, plen) == 0);
}

// Check if string ends with suffix
inline QValue q_endswith(QValue str, QValue suffix) {
    // Type guard: both must be STRING
    if (str.type != QValue::VAL_STRING || suffix.type != QValue::VAL_STRING) {
        return qv_null();
    }
    size_t slen = strlen(str.data.string_val);
    size_t suflen = strlen(suffix.data.string_val);
    if (suflen > slen) return qv_bool(false);
    return qv_bool(strcmp(str.data.string_val + slen - suflen, suffix.data.string_val) == 0);
}

// Replace all occurrences of old_str with new_str
inline QValue q_replace(QValue str, QValue old_str, QValue new_str) {
    // Type guard: all must be STRING
    if (str.type != QValue::VAL_STRING || old_str.type != QValue::VAL_STRING ||
        new_str.type != QValue::VAL_STRING) {
        return qv_null();
    }

    const char* s = str.data.string_val;
    const char* o = old_str.data.string_val;
    const char* n = new_str.data.string_val;
    size_t olen = strlen(o);
    size_t nlen = strlen(n);
    if (olen == 0) return str;

    // Count occurrences
    int count = 0;
    const char* tmp = s;
    while ((tmp = strstr(tmp, o)) != nullptr) {
        count++;
        tmp += olen;
    }

    // Allocate result (use atomic since it's just chars, no pointers)
    size_t slen = strlen(s);
    size_t rlen = slen + static_cast<size_t>(count) * (nlen - olen);
    char* result = static_cast<char*>(q_malloc_atomic(rlen + 1));
    char* dest = result;

    while (*s) {
        if (strncmp(s, o, olen) == 0) {
            strcpy(dest, n);
            dest += nlen;
            s += olen;
        } else {
            *dest++ = *s++;
        }
    }
    *dest = '\0';

    QValue q = qv_string(result);
    // GC will handle cleanup - no explicit free needed
    return q;
}

// Concatenate two strings
inline QValue q_concat(QValue a, QValue b) {
    // Type guard: both must be STRING
    if (a.type != QValue::VAL_STRING || b.type != QValue::VAL_STRING) {
        return qv_null();
    }
    size_t len = strlen(a.data.string_val) + strlen(b.data.string_val);
    char* result = static_cast<char*>(q_malloc_atomic(len + 1));
    strcpy(result, a.data.string_val);
    strcat(result, b.data.string_val);
    QValue q = qv_string(result);
    // GC will handle cleanup - no explicit free needed
    return q;
}

// ============================================================
// types/function.hpp
// ============================================================

// quark/types/function.hpp - Function value operations
// Call function value with 0 arguments
inline QValue q_call0(QValue f) {
    if (f.type != QValue::VAL_FUNC) return qv_null();
    return reinterpret_cast<QFunc0>(f.data.func_val)();
}

// Call function value with 1 argument
inline QValue q_call1(QValue f, QValue a) {
    if (f.type != QValue::VAL_FUNC) return qv_null();
    return reinterpret_cast<QFunc1>(f.data.func_val)(a);
}

// Call function value with 2 arguments
inline QValue q_call2(QValue f, QValue a, QValue b) {
    if (f.type != QValue::VAL_FUNC) return qv_null();
    return reinterpret_cast<QFunc2>(f.data.func_val)(a, b);
}

// Call function value with 3 arguments
inline QValue q_call3(QValue f, QValue a, QValue b, QValue c) {
    if (f.type != QValue::VAL_FUNC) return qv_null();
    return reinterpret_cast<QFunc3>(f.data.func_val)(a, b, c);
}

// Call function value with 4 arguments
inline QValue q_call4(QValue f, QValue a, QValue b, QValue c, QValue d) {
    if (f.type != QValue::VAL_FUNC) return qv_null();
    return reinterpret_cast<QFunc4>(f.data.func_val)(a, b, c, d);
}

// ============================================================
// builtins/io.hpp
// ============================================================

// quark/builtins/io.hpp - I/O operations
#include <cstdio>
#include <cstring>

// Print a QValue (without newline)
inline void print_qvalue(QValue v) {
    switch (v.type) {
        case QValue::VAL_INT:
            printf("%lld", v.data.int_val);
            break;
        case QValue::VAL_FLOAT:
            printf("%g", v.data.float_val);
            break;
        case QValue::VAL_STRING:
            printf("%s", v.data.string_val);
            break;
        case QValue::VAL_BOOL:
            printf(v.data.bool_val ? "true" : "false");
            break;
        case QValue::VAL_NULL:
            printf("null");
            break;
        case QValue::VAL_LIST:
            printf("[list len=%zu]", v.data.list_val ? v.data.list_val->size() : 0);
            break;
        case QValue::VAL_FUNC:
            printf("<function>");
            break;
        default:
            printf("<value>");
            break;
    }
}

// Print without newline
inline QValue q_print(QValue v) {
    print_qvalue(v);
    return qv_null();
}

// Print with newline
inline QValue q_println(QValue v) {
    print_qvalue(v);
    printf("\n");
    return qv_null();
}

// Read line from stdin
inline QValue q_input() {
    char buffer[4096];
    if (fgets(buffer, sizeof(buffer), stdin) != nullptr) {
        // Remove trailing newline
        size_t len = strlen(buffer);
        if (len > 0 && buffer[len - 1] == '\n') {
            buffer[len - 1] = '\0';
        }
        return qv_string(buffer);
    }
    return qv_string("");
}

// ============================================================
// builtins/conversion.hpp
// ============================================================

// quark/builtins/conversion.hpp - Type conversion operations
#include <cstdio>
#include <cstdlib>
#include <cstring>

// Get length of string or list
inline QValue q_len(QValue v) {
    switch (v.type) {
        case QValue::VAL_STRING:
            return qv_int(static_cast<long long>(strlen(v.data.string_val)));
        case QValue::VAL_LIST:
            return qv_int(v.data.list_val ? static_cast<long long>(v.data.list_val->size()) : 0);
        default:
            return qv_int(0);
    }
}

// Convert value to string
inline QValue q_str(QValue v) {
    char buffer[256];
    switch (v.type) {
        case QValue::VAL_INT:
            snprintf(buffer, sizeof(buffer), "%lld", v.data.int_val);
            return qv_string(buffer);
        case QValue::VAL_FLOAT:
            snprintf(buffer, sizeof(buffer), "%g", v.data.float_val);
            return qv_string(buffer);
        case QValue::VAL_BOOL:
            return qv_string(v.data.bool_val ? "true" : "false");
        case QValue::VAL_STRING:
            return v;
        case QValue::VAL_NULL:
            return qv_string("null");
        case QValue::VAL_LIST:
            snprintf(buffer, sizeof(buffer), "[list len=%zu]",
                     v.data.list_val ? v.data.list_val->size() : 0);
            return qv_string(buffer);
        case QValue::VAL_FUNC:
            return qv_string("<function>");
        default:
            return qv_string("<value>");
    }
}

// Convert value to integer
inline QValue q_int(QValue v) {
    switch (v.type) {
        case QValue::VAL_INT:
            return v;
        case QValue::VAL_FLOAT:
            return qv_int(static_cast<long long>(v.data.float_val));
        case QValue::VAL_BOOL:
            return qv_int(v.data.bool_val ? 1 : 0);
        case QValue::VAL_STRING:
            return qv_int(atoll(v.data.string_val));
        default:
            return qv_int(0);
    }
}

// Convert value to float
inline QValue q_float(QValue v) {
    switch (v.type) {
        case QValue::VAL_INT:
            return qv_float(static_cast<double>(v.data.int_val));
        case QValue::VAL_FLOAT:
            return v;
        case QValue::VAL_BOOL:
            return qv_float(v.data.bool_val ? 1.0 : 0.0);
        case QValue::VAL_STRING:
            return qv_float(atof(v.data.string_val));
        default:
            return qv_float(0.0);
    }
}

// Convert value to boolean
inline QValue q_bool(QValue v) {
    return qv_bool(q_truthy(v));
}

// ============================================================
// builtins/math.hpp
// ============================================================

// quark/builtins/math.hpp - Math operations
#include <cmath>
#include <cstdlib>

// Helper functions to_double() and either_float() are defined in arithmetic.hpp
// (removed from here to avoid duplication in the concatenated runtime.hpp)

// Absolute value
inline QValue q_abs(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    if (v.type == QValue::VAL_FLOAT) {
        return qv_float(fabs(v.data.float_val));
    }
    return qv_int(llabs(v.data.int_val));
}

// Minimum of two values
inline QValue q_min(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        double av = quark::detail::to_double(a);
        double bv = quark::detail::to_double(b);
        return qv_float(av < bv ? av : bv);
    }
    return qv_int(a.data.int_val < b.data.int_val ? a.data.int_val : b.data.int_val);
}

// Maximum of two values
inline QValue q_max(QValue a, QValue b) {
    // Type guard: only INT and FLOAT are valid
    if ((a.type != QValue::VAL_INT && a.type != QValue::VAL_FLOAT) ||
        (b.type != QValue::VAL_INT && b.type != QValue::VAL_FLOAT)) {
        return qv_null();
    }
    if (quark::detail::either_float(a, b)) {
        double av = quark::detail::to_double(a);
        double bv = quark::detail::to_double(b);
        return qv_float(av > bv ? av : bv);
    }
    return qv_int(a.data.int_val > b.data.int_val ? a.data.int_val : b.data.int_val);
}

// Square root (always returns float)
inline QValue q_sqrt(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    double val = quark::detail::to_double(v);
    // Check for negative values
    if (val < 0.0) {
        return qv_null();
    }
    return qv_float(sqrt(val));
}

// Floor (returns int)
inline QValue q_floor(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    if (v.type == QValue::VAL_INT) return v;
    return qv_int(static_cast<long long>(floor(v.data.float_val)));
}

// Ceiling (returns int)
inline QValue q_ceil(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    if (v.type == QValue::VAL_INT) return v;
    return qv_int(static_cast<long long>(ceil(v.data.float_val)));
}

// Round to nearest integer (returns int)
inline QValue q_round(QValue v) {
    // Type guard: only INT and FLOAT are valid
    if (v.type != QValue::VAL_INT && v.type != QValue::VAL_FLOAT) {
        return qv_null();
    }
    if (v.type == QValue::VAL_INT) return v;
    return qv_int(static_cast<long long>(round(v.data.float_val)));
}

#endif // QUARK_RUNTIME_HPP
